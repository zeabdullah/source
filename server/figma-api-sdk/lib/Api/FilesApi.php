<?php
/**
 * FilesApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.33.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * FilesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FilesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'getFile' => [
            'application/json',
        ],
        'getFileMeta' => [
            'application/json',
        ],
        'getFileNodes' => [
            'application/json',
        ],
        'getFileVersions' => [
            'application/json',
        ],
        'getImageFills' => [
            'application/json',
        ],
        'getImages' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getFile
     *
     * Get file JSON
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  string|null $ids Comma separated list of nodes that you care about in the document. If specified, only a subset of the document will be returned corresponding to the nodes listed, their children, and everything between the root node and the listed nodes.  Note: There may be other nodes included in the returned JSON that are outside the ancestor chains of the desired nodes. The response may also include dependencies of anything in the nodes&#39; subtrees. For example, if a node subtree contains an instance of a local component that lives elsewhere in that file, that component and its ancestor chain will also be included.  For historical reasons, top-level canvas nodes are always returned, regardless of whether they are listed in the &#x60;ids&#x60; parameter. This quirk may be removed in a future version of the API. (optional)
     * @param  float|null $depth Positive integer representing how deep into the document tree to traverse. For example, setting this to 1 returns only Pages, setting it to 2 returns Pages and all top level objects on each page. Not setting this parameter returns all nodes. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  bool|null $branch_data Returns branch metadata for the requested file. If the file is a branch, the main file&#39;s key will be included in the returned response. If the file has branches, their metadata will be included in the returned response. Default: false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47
     */
    public function getFile($file_key, $version = null, $ids = null, $depth = null, $geometry = null, $plugin_data = null, $branch_data = false, string $contentType = self::contentTypes['getFile'][0])
    {
        list($response) = $this->getFileWithHttpInfo($file_key, $version, $ids, $depth, $geometry, $plugin_data, $branch_data, $contentType);
        return $response;
    }

    /**
     * Operation getFileWithHttpInfo
     *
     * Get file JSON
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  string|null $ids Comma separated list of nodes that you care about in the document. If specified, only a subset of the document will be returned corresponding to the nodes listed, their children, and everything between the root node and the listed nodes.  Note: There may be other nodes included in the returned JSON that are outside the ancestor chains of the desired nodes. The response may also include dependencies of anything in the nodes&#39; subtrees. For example, if a node subtree contains an instance of a local component that lives elsewhere in that file, that component and its ancestor chain will also be included.  For historical reasons, top-level canvas nodes are always returned, regardless of whether they are listed in the &#x60;ids&#x60; parameter. This quirk may be removed in a future version of the API. (optional)
     * @param  float|null $depth Positive integer representing how deep into the document tree to traverse. For example, setting this to 1 returns only Pages, setting it to 2 returns Pages and all top level objects on each page. Not setting this parameter returns all nodes. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  bool|null $branch_data Returns branch metadata for the requested file. If the file is a branch, the main file&#39;s key will be included in the returned response. If the file has branches, their metadata will be included in the returned response. Default: false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileWithHttpInfo($file_key, $version = null, $ids = null, $depth = null, $geometry = null, $plugin_data = null, $branch_data = false, string $contentType = self::contentTypes['getFile'][0])
    {
        $request = $this->getFileRequest($file_key, $version, $ids, $depth, $geometry, $plugin_data, $branch_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject38',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject41',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject43',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject45',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject47',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InlineObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject38',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject41',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject43',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject45',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject47',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileAsync
     *
     * Get file JSON
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  string|null $ids Comma separated list of nodes that you care about in the document. If specified, only a subset of the document will be returned corresponding to the nodes listed, their children, and everything between the root node and the listed nodes.  Note: There may be other nodes included in the returned JSON that are outside the ancestor chains of the desired nodes. The response may also include dependencies of anything in the nodes&#39; subtrees. For example, if a node subtree contains an instance of a local component that lives elsewhere in that file, that component and its ancestor chain will also be included.  For historical reasons, top-level canvas nodes are always returned, regardless of whether they are listed in the &#x60;ids&#x60; parameter. This quirk may be removed in a future version of the API. (optional)
     * @param  float|null $depth Positive integer representing how deep into the document tree to traverse. For example, setting this to 1 returns only Pages, setting it to 2 returns Pages and all top level objects on each page. Not setting this parameter returns all nodes. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  bool|null $branch_data Returns branch metadata for the requested file. If the file is a branch, the main file&#39;s key will be included in the returned response. If the file has branches, their metadata will be included in the returned response. Default: false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAsync($file_key, $version = null, $ids = null, $depth = null, $geometry = null, $plugin_data = null, $branch_data = false, string $contentType = self::contentTypes['getFile'][0])
    {
        return $this->getFileAsyncWithHttpInfo($file_key, $version, $ids, $depth, $geometry, $plugin_data, $branch_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileAsyncWithHttpInfo
     *
     * Get file JSON
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  string|null $ids Comma separated list of nodes that you care about in the document. If specified, only a subset of the document will be returned corresponding to the nodes listed, their children, and everything between the root node and the listed nodes.  Note: There may be other nodes included in the returned JSON that are outside the ancestor chains of the desired nodes. The response may also include dependencies of anything in the nodes&#39; subtrees. For example, if a node subtree contains an instance of a local component that lives elsewhere in that file, that component and its ancestor chain will also be included.  For historical reasons, top-level canvas nodes are always returned, regardless of whether they are listed in the &#x60;ids&#x60; parameter. This quirk may be removed in a future version of the API. (optional)
     * @param  float|null $depth Positive integer representing how deep into the document tree to traverse. For example, setting this to 1 returns only Pages, setting it to 2 returns Pages and all top level objects on each page. Not setting this parameter returns all nodes. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  bool|null $branch_data Returns branch metadata for the requested file. If the file is a branch, the main file&#39;s key will be included in the returned response. If the file has branches, their metadata will be included in the returned response. Default: false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileAsyncWithHttpInfo($file_key, $version = null, $ids = null, $depth = null, $geometry = null, $plugin_data = null, $branch_data = false, string $contentType = self::contentTypes['getFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject';
        $request = $this->getFileRequest($file_key, $version, $ids, $depth, $geometry, $plugin_data, $branch_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFile'
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  string|null $ids Comma separated list of nodes that you care about in the document. If specified, only a subset of the document will be returned corresponding to the nodes listed, their children, and everything between the root node and the listed nodes.  Note: There may be other nodes included in the returned JSON that are outside the ancestor chains of the desired nodes. The response may also include dependencies of anything in the nodes&#39; subtrees. For example, if a node subtree contains an instance of a local component that lives elsewhere in that file, that component and its ancestor chain will also be included.  For historical reasons, top-level canvas nodes are always returned, regardless of whether they are listed in the &#x60;ids&#x60; parameter. This quirk may be removed in a future version of the API. (optional)
     * @param  float|null $depth Positive integer representing how deep into the document tree to traverse. For example, setting this to 1 returns only Pages, setting it to 2 returns Pages and all top level objects on each page. Not setting this parameter returns all nodes. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  bool|null $branch_data Returns branch metadata for the requested file. If the file is a branch, the main file&#39;s key will be included in the returned response. If the file has branches, their metadata will be included in the returned response. Default: false. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileRequest($file_key, $version = null, $ids = null, $depth = null, $geometry = null, $plugin_data = null, $branch_data = false, string $contentType = self::contentTypes['getFile'][0])
    {

        // verify the required parameter 'file_key' is set
        if ($file_key === null || (is_array($file_key) && count($file_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_key when calling getFile'
            );
        }








        $resourcePath = '/v1/files/{file_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth,
            'depth', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $geometry,
            'geometry', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plugin_data,
            'plugin_data', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $branch_data,
            'branch_data', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_key !== null) {
            $resourcePath = str_replace(
                '{' . 'file_key' . '}',
                ObjectSerializer::toPathValue($file_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Figma-Token');
        if ($apiKey !== null) {
            $headers['X-Figma-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileMeta
     *
     * Get file metadata
     *
     * @param  string $file_key File to get metadata for. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileMeta'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject4|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47
     */
    public function getFileMeta($file_key, string $contentType = self::contentTypes['getFileMeta'][0])
    {
        list($response) = $this->getFileMetaWithHttpInfo($file_key, $contentType);
        return $response;
    }

    /**
     * Operation getFileMetaWithHttpInfo
     *
     * Get file metadata
     *
     * @param  string $file_key File to get metadata for. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileMeta'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject4|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileMetaWithHttpInfo($file_key, string $contentType = self::contentTypes['getFileMeta'][0])
    {
        $request = $this->getFileMetaRequest($file_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject4',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject38',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject41',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject43',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject45',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject47',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InlineObject4',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject38',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject41',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject43',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject45',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject47',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileMetaAsync
     *
     * Get file metadata
     *
     * @param  string $file_key File to get metadata for. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileMeta'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileMetaAsync($file_key, string $contentType = self::contentTypes['getFileMeta'][0])
    {
        return $this->getFileMetaAsyncWithHttpInfo($file_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileMetaAsyncWithHttpInfo
     *
     * Get file metadata
     *
     * @param  string $file_key File to get metadata for. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileMeta'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileMetaAsyncWithHttpInfo($file_key, string $contentType = self::contentTypes['getFileMeta'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject4';
        $request = $this->getFileMetaRequest($file_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileMeta'
     *
     * @param  string $file_key File to get metadata for. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileMeta'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileMetaRequest($file_key, string $contentType = self::contentTypes['getFileMeta'][0])
    {

        // verify the required parameter 'file_key' is set
        if ($file_key === null || (is_array($file_key) && count($file_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_key when calling getFileMeta'
            );
        }


        $resourcePath = '/v1/files/{file_key}/meta';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_key !== null) {
            $resourcePath = str_replace(
                '{' . 'file_key' . '}',
                ObjectSerializer::toPathValue($file_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Figma-Token');
        if ($apiKey !== null) {
            $headers['X-Figma-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileNodes
     *
     * Get file JSON for specific nodes
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to retrieve and convert. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $depth Positive integer representing how deep into the node tree to traverse. For example, setting this to 1 will return only the children directly underneath the desired nodes. Not setting this parameter returns all nodes.  Note: this parameter behaves differently from the same parameter in the &#x60;GET /v1/files/:key&#x60; endpoint. In this endpoint, the depth will be counted starting from the desired node rather than the document root node. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileNodes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47
     */
    public function getFileNodes($file_key, $ids, $version = null, $depth = null, $geometry = null, $plugin_data = null, string $contentType = self::contentTypes['getFileNodes'][0])
    {
        list($response) = $this->getFileNodesWithHttpInfo($file_key, $ids, $version, $depth, $geometry, $plugin_data, $contentType);
        return $response;
    }

    /**
     * Operation getFileNodesWithHttpInfo
     *
     * Get file JSON for specific nodes
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to retrieve and convert. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $depth Positive integer representing how deep into the node tree to traverse. For example, setting this to 1 will return only the children directly underneath the desired nodes. Not setting this parameter returns all nodes.  Note: this parameter behaves differently from the same parameter in the &#x60;GET /v1/files/:key&#x60; endpoint. In this endpoint, the depth will be counted starting from the desired node rather than the document root node. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileNodes'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject1|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileNodesWithHttpInfo($file_key, $ids, $version = null, $depth = null, $geometry = null, $plugin_data = null, string $contentType = self::contentTypes['getFileNodes'][0])
    {
        $request = $this->getFileNodesRequest($file_key, $ids, $version, $depth, $geometry, $plugin_data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject1',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject38',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject41',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject43',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject45',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject47',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InlineObject1',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject38',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject41',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject43',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject45',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject47',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileNodesAsync
     *
     * Get file JSON for specific nodes
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to retrieve and convert. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $depth Positive integer representing how deep into the node tree to traverse. For example, setting this to 1 will return only the children directly underneath the desired nodes. Not setting this parameter returns all nodes.  Note: this parameter behaves differently from the same parameter in the &#x60;GET /v1/files/:key&#x60; endpoint. In this endpoint, the depth will be counted starting from the desired node rather than the document root node. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileNodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileNodesAsync($file_key, $ids, $version = null, $depth = null, $geometry = null, $plugin_data = null, string $contentType = self::contentTypes['getFileNodes'][0])
    {
        return $this->getFileNodesAsyncWithHttpInfo($file_key, $ids, $version, $depth, $geometry, $plugin_data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileNodesAsyncWithHttpInfo
     *
     * Get file JSON for specific nodes
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to retrieve and convert. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $depth Positive integer representing how deep into the node tree to traverse. For example, setting this to 1 will return only the children directly underneath the desired nodes. Not setting this parameter returns all nodes.  Note: this parameter behaves differently from the same parameter in the &#x60;GET /v1/files/:key&#x60; endpoint. In this endpoint, the depth will be counted starting from the desired node rather than the document root node. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileNodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileNodesAsyncWithHttpInfo($file_key, $ids, $version = null, $depth = null, $geometry = null, $plugin_data = null, string $contentType = self::contentTypes['getFileNodes'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject1';
        $request = $this->getFileNodesRequest($file_key, $ids, $version, $depth, $geometry, $plugin_data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileNodes'
     *
     * @param  string $file_key File to export JSON from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to retrieve and convert. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $depth Positive integer representing how deep into the node tree to traverse. For example, setting this to 1 will return only the children directly underneath the desired nodes. Not setting this parameter returns all nodes.  Note: this parameter behaves differently from the same parameter in the &#x60;GET /v1/files/:key&#x60; endpoint. In this endpoint, the depth will be counted starting from the desired node rather than the document root node. (optional)
     * @param  string|null $geometry Set to \&quot;paths\&quot; to export vector data. (optional)
     * @param  string|null $plugin_data A comma separated list of plugin IDs and/or the string \&quot;shared\&quot;. Any data present in the document written by those plugins will be included in the result in the &#x60;pluginData&#x60; and &#x60;sharedPluginData&#x60; properties. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileNodes'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileNodesRequest($file_key, $ids, $version = null, $depth = null, $geometry = null, $plugin_data = null, string $contentType = self::contentTypes['getFileNodes'][0])
    {

        // verify the required parameter 'file_key' is set
        if ($file_key === null || (is_array($file_key) && count($file_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_key when calling getFileNodes'
            );
        }

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getFileNodes'
            );
        }






        $resourcePath = '/v1/files/{file_key}/nodes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $depth,
            'depth', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $geometry,
            'geometry', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $plugin_data,
            'plugin_data', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_key !== null) {
            $resourcePath = str_replace(
                '{' . 'file_key' . '}',
                ObjectSerializer::toPathValue($file_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Figma-Token');
        if ($apiKey !== null) {
            $headers['X-Figma-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileVersions
     *
     * Get versions of a file
     *
     * @param  string $file_key File to get version history from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  float|null $page_size The number of items returned in a page of the response. If not included, &#x60;page_size&#x60; is &#x60;30&#x60;. (optional)
     * @param  float|null $before A version ID for one of the versions in the history. Gets versions before this ID. Used for paginating. If the response is not paginated, this link returns the same data in the current response. (optional)
     * @param  float|null $after A version ID for one of the versions in the history. Gets versions after this ID. Used for paginating. If the response is not paginated, this property is not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject7|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47
     */
    public function getFileVersions($file_key, $page_size = null, $before = null, $after = null, string $contentType = self::contentTypes['getFileVersions'][0])
    {
        list($response) = $this->getFileVersionsWithHttpInfo($file_key, $page_size, $before, $after, $contentType);
        return $response;
    }

    /**
     * Operation getFileVersionsWithHttpInfo
     *
     * Get versions of a file
     *
     * @param  string $file_key File to get version history from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  float|null $page_size The number of items returned in a page of the response. If not included, &#x60;page_size&#x60; is &#x60;30&#x60;. (optional)
     * @param  float|null $before A version ID for one of the versions in the history. Gets versions before this ID. Used for paginating. If the response is not paginated, this link returns the same data in the current response. (optional)
     * @param  float|null $after A version ID for one of the versions in the history. Gets versions after this ID. Used for paginating. If the response is not paginated, this property is not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject7|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileVersionsWithHttpInfo($file_key, $page_size = null, $before = null, $after = null, string $contentType = self::contentTypes['getFileVersions'][0])
    {
        $request = $this->getFileVersionsRequest($file_key, $page_size, $before, $after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject7',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject41',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject43',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject45',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject47',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InlineObject7',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject7',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject41',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject43',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject45',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject47',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileVersionsAsync
     *
     * Get versions of a file
     *
     * @param  string $file_key File to get version history from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  float|null $page_size The number of items returned in a page of the response. If not included, &#x60;page_size&#x60; is &#x60;30&#x60;. (optional)
     * @param  float|null $before A version ID for one of the versions in the history. Gets versions before this ID. Used for paginating. If the response is not paginated, this link returns the same data in the current response. (optional)
     * @param  float|null $after A version ID for one of the versions in the history. Gets versions after this ID. Used for paginating. If the response is not paginated, this property is not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileVersionsAsync($file_key, $page_size = null, $before = null, $after = null, string $contentType = self::contentTypes['getFileVersions'][0])
    {
        return $this->getFileVersionsAsyncWithHttpInfo($file_key, $page_size, $before, $after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileVersionsAsyncWithHttpInfo
     *
     * Get versions of a file
     *
     * @param  string $file_key File to get version history from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  float|null $page_size The number of items returned in a page of the response. If not included, &#x60;page_size&#x60; is &#x60;30&#x60;. (optional)
     * @param  float|null $before A version ID for one of the versions in the history. Gets versions before this ID. Used for paginating. If the response is not paginated, this link returns the same data in the current response. (optional)
     * @param  float|null $after A version ID for one of the versions in the history. Gets versions after this ID. Used for paginating. If the response is not paginated, this property is not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileVersionsAsyncWithHttpInfo($file_key, $page_size = null, $before = null, $after = null, string $contentType = self::contentTypes['getFileVersions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject7';
        $request = $this->getFileVersionsRequest($file_key, $page_size, $before, $after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileVersions'
     *
     * @param  string $file_key File to get version history from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  float|null $page_size The number of items returned in a page of the response. If not included, &#x60;page_size&#x60; is &#x60;30&#x60;. (optional)
     * @param  float|null $before A version ID for one of the versions in the history. Gets versions before this ID. Used for paginating. If the response is not paginated, this link returns the same data in the current response. (optional)
     * @param  float|null $after A version ID for one of the versions in the history. Gets versions after this ID. Used for paginating. If the response is not paginated, this property is not included. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileVersionsRequest($file_key, $page_size = null, $before = null, $after = null, string $contentType = self::contentTypes['getFileVersions'][0])
    {

        // verify the required parameter 'file_key' is set
        if ($file_key === null || (is_array($file_key) && count($file_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_key when calling getFileVersions'
            );
        }

        if ($page_size !== null && $page_size > 50) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling FilesApi.getFileVersions, must be smaller than or equal to 50.');
        }
        



        $resourcePath = '/v1/files/{file_key}/versions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'page_size', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $after,
            'after', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_key !== null) {
            $resourcePath = str_replace(
                '{' . 'file_key' . '}',
                ObjectSerializer::toPathValue($file_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Figma-Token');
        if ($apiKey !== null) {
            $headers['X-Figma-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImageFills
     *
     * Get image fills
     *
     * @param  string $file_key File to get image URLs from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImageFills'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject3|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47
     */
    public function getImageFills($file_key, string $contentType = self::contentTypes['getImageFills'][0])
    {
        list($response) = $this->getImageFillsWithHttpInfo($file_key, $contentType);
        return $response;
    }

    /**
     * Operation getImageFillsWithHttpInfo
     *
     * Get image fills
     *
     * @param  string $file_key File to get image URLs from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImageFills'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject3|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImageFillsWithHttpInfo($file_key, string $contentType = self::contentTypes['getImageFills'][0])
    {
        $request = $this->getImageFillsRequest($file_key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject3',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject38',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject41',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject43',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject45',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject47',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InlineObject3',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject3',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject38',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject41',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject43',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject45',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject47',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getImageFillsAsync
     *
     * Get image fills
     *
     * @param  string $file_key File to get image URLs from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImageFills'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageFillsAsync($file_key, string $contentType = self::contentTypes['getImageFills'][0])
    {
        return $this->getImageFillsAsyncWithHttpInfo($file_key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImageFillsAsyncWithHttpInfo
     *
     * Get image fills
     *
     * @param  string $file_key File to get image URLs from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImageFills'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImageFillsAsyncWithHttpInfo($file_key, string $contentType = self::contentTypes['getImageFills'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject3';
        $request = $this->getImageFillsRequest($file_key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImageFills'
     *
     * @param  string $file_key File to get image URLs from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImageFills'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getImageFillsRequest($file_key, string $contentType = self::contentTypes['getImageFills'][0])
    {

        // verify the required parameter 'file_key' is set
        if ($file_key === null || (is_array($file_key) && count($file_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_key when calling getImageFills'
            );
        }


        $resourcePath = '/v1/files/{file_key}/images';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_key !== null) {
            $resourcePath = str_replace(
                '{' . 'file_key' . '}',
                ObjectSerializer::toPathValue($file_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Figma-Token');
        if ($apiKey !== null) {
            $headers['X-Figma-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getImages
     *
     * Render images of file nodes
     *
     * @param  string $file_key File to export images from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to render. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $scale A number between 0.01 and 4, the image scaling factor. (optional)
     * @param  string|null $format A string enum for the image output format. (optional, default to 'png')
     * @param  bool|null $svg_outline_text Whether text elements are rendered as outlines (vector paths) or as &#x60;&lt;text&gt;&#x60; elements in SVGs.  Rendering text elements as outlines guarantees that the text looks exactly the same in the SVG as it does in the browser/inside Figma.  Exporting as &#x60;&lt;text&gt;&#x60; allows text to be selectable inside SVGs and generally makes the SVG easier to read. However, this relies on the browser&#39;s rendering engine which can vary between browsers and/or operating systems. As such, visual accuracy is not guaranteed as the result could look different than in Figma. (optional, default to true)
     * @param  bool|null $svg_include_id Whether to include id attributes for all SVG elements. Adds the layer name to the &#x60;id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_include_node_id Whether to include node id attributes for all SVG elements. Adds the node id to a &#x60;data-node-id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_simplify_stroke Whether to simplify inside/outside strokes and use stroke attribute if possible instead of &#x60;&lt;mask&gt;&#x60;. (optional, default to true)
     * @param  bool|null $contents_only Whether content that overlaps the node should be excluded from rendering. Passing false (i.e., rendering overlaps) may increase processing time, since more of the document must be included in rendering. (optional, default to true)
     * @param  bool|null $use_absolute_bounds Use the full dimensions of the node regardless of whether or not it is cropped or the space around it is empty. Use this to export text nodes without cropping. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InlineObject2|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47
     */
    public function getImages($file_key, $ids, $version = null, $scale = null, $format = 'png', $svg_outline_text = true, $svg_include_id = false, $svg_include_node_id = false, $svg_simplify_stroke = true, $contents_only = true, $use_absolute_bounds = false, string $contentType = self::contentTypes['getImages'][0])
    {
        list($response) = $this->getImagesWithHttpInfo($file_key, $ids, $version, $scale, $format, $svg_outline_text, $svg_include_id, $svg_include_node_id, $svg_simplify_stroke, $contents_only, $use_absolute_bounds, $contentType);
        return $response;
    }

    /**
     * Operation getImagesWithHttpInfo
     *
     * Render images of file nodes
     *
     * @param  string $file_key File to export images from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to render. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $scale A number between 0.01 and 4, the image scaling factor. (optional)
     * @param  string|null $format A string enum for the image output format. (optional, default to 'png')
     * @param  bool|null $svg_outline_text Whether text elements are rendered as outlines (vector paths) or as &#x60;&lt;text&gt;&#x60; elements in SVGs.  Rendering text elements as outlines guarantees that the text looks exactly the same in the SVG as it does in the browser/inside Figma.  Exporting as &#x60;&lt;text&gt;&#x60; allows text to be selectable inside SVGs and generally makes the SVG easier to read. However, this relies on the browser&#39;s rendering engine which can vary between browsers and/or operating systems. As such, visual accuracy is not guaranteed as the result could look different than in Figma. (optional, default to true)
     * @param  bool|null $svg_include_id Whether to include id attributes for all SVG elements. Adds the layer name to the &#x60;id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_include_node_id Whether to include node id attributes for all SVG elements. Adds the node id to a &#x60;data-node-id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_simplify_stroke Whether to simplify inside/outside strokes and use stroke attribute if possible instead of &#x60;&lt;mask&gt;&#x60;. (optional, default to true)
     * @param  bool|null $contents_only Whether content that overlaps the node should be excluded from rendering. Passing false (i.e., rendering overlaps) may increase processing time, since more of the document must be included in rendering. (optional, default to true)
     * @param  bool|null $use_absolute_bounds Use the full dimensions of the node regardless of whether or not it is cropped or the space around it is empty. Use this to export text nodes without cropping. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImages'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InlineObject2|\OpenAPI\Client\Model\InlineObject38|\OpenAPI\Client\Model\InlineObject41|\OpenAPI\Client\Model\InlineObject43|\OpenAPI\Client\Model\InlineObject45|\OpenAPI\Client\Model\InlineObject47, HTTP status code, HTTP response headers (array of strings)
     */
    public function getImagesWithHttpInfo($file_key, $ids, $version = null, $scale = null, $format = 'png', $svg_outline_text = true, $svg_include_id = false, $svg_include_node_id = false, $svg_simplify_stroke = true, $contents_only = true, $use_absolute_bounds = false, string $contentType = self::contentTypes['getImages'][0])
    {
        $request = $this->getImagesRequest($file_key, $ids, $version, $scale, $format, $svg_outline_text, $svg_include_id, $svg_include_node_id, $svg_simplify_stroke, $contents_only, $use_absolute_bounds, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject2',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject38',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject41',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject43',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject45',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\InlineObject47',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\InlineObject2',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject2',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject38',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject41',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject43',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject45',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InlineObject47',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getImagesAsync
     *
     * Render images of file nodes
     *
     * @param  string $file_key File to export images from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to render. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $scale A number between 0.01 and 4, the image scaling factor. (optional)
     * @param  string|null $format A string enum for the image output format. (optional, default to 'png')
     * @param  bool|null $svg_outline_text Whether text elements are rendered as outlines (vector paths) or as &#x60;&lt;text&gt;&#x60; elements in SVGs.  Rendering text elements as outlines guarantees that the text looks exactly the same in the SVG as it does in the browser/inside Figma.  Exporting as &#x60;&lt;text&gt;&#x60; allows text to be selectable inside SVGs and generally makes the SVG easier to read. However, this relies on the browser&#39;s rendering engine which can vary between browsers and/or operating systems. As such, visual accuracy is not guaranteed as the result could look different than in Figma. (optional, default to true)
     * @param  bool|null $svg_include_id Whether to include id attributes for all SVG elements. Adds the layer name to the &#x60;id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_include_node_id Whether to include node id attributes for all SVG elements. Adds the node id to a &#x60;data-node-id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_simplify_stroke Whether to simplify inside/outside strokes and use stroke attribute if possible instead of &#x60;&lt;mask&gt;&#x60;. (optional, default to true)
     * @param  bool|null $contents_only Whether content that overlaps the node should be excluded from rendering. Passing false (i.e., rendering overlaps) may increase processing time, since more of the document must be included in rendering. (optional, default to true)
     * @param  bool|null $use_absolute_bounds Use the full dimensions of the node regardless of whether or not it is cropped or the space around it is empty. Use this to export text nodes without cropping. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsync($file_key, $ids, $version = null, $scale = null, $format = 'png', $svg_outline_text = true, $svg_include_id = false, $svg_include_node_id = false, $svg_simplify_stroke = true, $contents_only = true, $use_absolute_bounds = false, string $contentType = self::contentTypes['getImages'][0])
    {
        return $this->getImagesAsyncWithHttpInfo($file_key, $ids, $version, $scale, $format, $svg_outline_text, $svg_include_id, $svg_include_node_id, $svg_simplify_stroke, $contents_only, $use_absolute_bounds, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getImagesAsyncWithHttpInfo
     *
     * Render images of file nodes
     *
     * @param  string $file_key File to export images from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to render. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $scale A number between 0.01 and 4, the image scaling factor. (optional)
     * @param  string|null $format A string enum for the image output format. (optional, default to 'png')
     * @param  bool|null $svg_outline_text Whether text elements are rendered as outlines (vector paths) or as &#x60;&lt;text&gt;&#x60; elements in SVGs.  Rendering text elements as outlines guarantees that the text looks exactly the same in the SVG as it does in the browser/inside Figma.  Exporting as &#x60;&lt;text&gt;&#x60; allows text to be selectable inside SVGs and generally makes the SVG easier to read. However, this relies on the browser&#39;s rendering engine which can vary between browsers and/or operating systems. As such, visual accuracy is not guaranteed as the result could look different than in Figma. (optional, default to true)
     * @param  bool|null $svg_include_id Whether to include id attributes for all SVG elements. Adds the layer name to the &#x60;id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_include_node_id Whether to include node id attributes for all SVG elements. Adds the node id to a &#x60;data-node-id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_simplify_stroke Whether to simplify inside/outside strokes and use stroke attribute if possible instead of &#x60;&lt;mask&gt;&#x60;. (optional, default to true)
     * @param  bool|null $contents_only Whether content that overlaps the node should be excluded from rendering. Passing false (i.e., rendering overlaps) may increase processing time, since more of the document must be included in rendering. (optional, default to true)
     * @param  bool|null $use_absolute_bounds Use the full dimensions of the node regardless of whether or not it is cropped or the space around it is empty. Use this to export text nodes without cropping. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getImagesAsyncWithHttpInfo($file_key, $ids, $version = null, $scale = null, $format = 'png', $svg_outline_text = true, $svg_include_id = false, $svg_include_node_id = false, $svg_simplify_stroke = true, $contents_only = true, $use_absolute_bounds = false, string $contentType = self::contentTypes['getImages'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InlineObject2';
        $request = $this->getImagesRequest($file_key, $ids, $version, $scale, $format, $svg_outline_text, $svg_include_id, $svg_include_node_id, $svg_simplify_stroke, $contents_only, $use_absolute_bounds, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getImages'
     *
     * @param  string $file_key File to export images from. This can be a file key or branch key. Use &#x60;GET /v1/files/:key&#x60; with the &#x60;branch_data&#x60; query param to get the branch key. (required)
     * @param  string $ids A comma separated list of node IDs to render. (required)
     * @param  string|null $version A specific version ID to get. Omitting this will get the current version of the file. (optional)
     * @param  float|null $scale A number between 0.01 and 4, the image scaling factor. (optional)
     * @param  string|null $format A string enum for the image output format. (optional, default to 'png')
     * @param  bool|null $svg_outline_text Whether text elements are rendered as outlines (vector paths) or as &#x60;&lt;text&gt;&#x60; elements in SVGs.  Rendering text elements as outlines guarantees that the text looks exactly the same in the SVG as it does in the browser/inside Figma.  Exporting as &#x60;&lt;text&gt;&#x60; allows text to be selectable inside SVGs and generally makes the SVG easier to read. However, this relies on the browser&#39;s rendering engine which can vary between browsers and/or operating systems. As such, visual accuracy is not guaranteed as the result could look different than in Figma. (optional, default to true)
     * @param  bool|null $svg_include_id Whether to include id attributes for all SVG elements. Adds the layer name to the &#x60;id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_include_node_id Whether to include node id attributes for all SVG elements. Adds the node id to a &#x60;data-node-id&#x60; attribute of an svg element. (optional, default to false)
     * @param  bool|null $svg_simplify_stroke Whether to simplify inside/outside strokes and use stroke attribute if possible instead of &#x60;&lt;mask&gt;&#x60;. (optional, default to true)
     * @param  bool|null $contents_only Whether content that overlaps the node should be excluded from rendering. Passing false (i.e., rendering overlaps) may increase processing time, since more of the document must be included in rendering. (optional, default to true)
     * @param  bool|null $use_absolute_bounds Use the full dimensions of the node regardless of whether or not it is cropped or the space around it is empty. Use this to export text nodes without cropping. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getImages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getImagesRequest($file_key, $ids, $version = null, $scale = null, $format = 'png', $svg_outline_text = true, $svg_include_id = false, $svg_include_node_id = false, $svg_simplify_stroke = true, $contents_only = true, $use_absolute_bounds = false, string $contentType = self::contentTypes['getImages'][0])
    {

        // verify the required parameter 'file_key' is set
        if ($file_key === null || (is_array($file_key) && count($file_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_key when calling getImages'
            );
        }

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getImages'
            );
        }


        if ($scale !== null && $scale > 4) {
            throw new \InvalidArgumentException('invalid value for "$scale" when calling FilesApi.getImages, must be smaller than or equal to 4.');
        }
        if ($scale !== null && $scale < 0.01) {
            throw new \InvalidArgumentException('invalid value for "$scale" when calling FilesApi.getImages, must be bigger than or equal to 0.01.');
        }
        








        $resourcePath = '/v1/images/{file_key}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scale,
            'scale', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $format,
            'format', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $svg_outline_text,
            'svg_outline_text', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $svg_include_id,
            'svg_include_id', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $svg_include_node_id,
            'svg_include_node_id', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $svg_simplify_stroke,
            'svg_simplify_stroke', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contents_only,
            'contents_only', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_absolute_bounds,
            'use_absolute_bounds', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_key !== null) {
            $resourcePath = str_replace(
                '{' . 'file_key' . '}',
                ObjectSerializer::toPathValue($file_key),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Figma-Token');
        if ($apiKey !== null) {
            $headers['X-Figma-Token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
