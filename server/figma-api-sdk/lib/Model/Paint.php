<?php
/**
 * Paint
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.33.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * Paint Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class Paint implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Paint';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'type' => 'string',
        'color' => '\OpenAPI\Client\Model\RGBA',
        'bound_variables' => '\OpenAPI\Client\Model\SolidPaintAllOfBoundVariables',
        'visible' => 'bool',
        'opacity' => 'float',
        'blend_mode' => '\OpenAPI\Client\Model\BlendMode',
        'gradient_handle_positions' => '\OpenAPI\Client\Model\Vector[]',
        'gradient_stops' => '\OpenAPI\Client\Model\ColorStop[]',
        'scale_mode' => 'string',
        'image_ref' => 'string',
        'image_transform' => 'float[][]',
        'scaling_factor' => 'float',
        'filters' => '\OpenAPI\Client\Model\ImageFilters',
        'rotation' => 'float',
        'gif_ref' => 'string',
        'source_node_id' => 'string',
        'tile_type' => 'string',
        'spacing' => '\OpenAPI\Client\Model\Vector',
        'horizontal_alignment' => 'string',
        'vertical_alignment' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'type' => null,
        'color' => null,
        'bound_variables' => null,
        'visible' => null,
        'opacity' => null,
        'blend_mode' => null,
        'gradient_handle_positions' => null,
        'gradient_stops' => null,
        'scale_mode' => null,
        'image_ref' => null,
        'image_transform' => null,
        'scaling_factor' => null,
        'filters' => null,
        'rotation' => null,
        'gif_ref' => null,
        'source_node_id' => null,
        'tile_type' => null,
        'spacing' => null,
        'horizontal_alignment' => null,
        'vertical_alignment' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'type' => false,
        'color' => false,
        'bound_variables' => false,
        'visible' => false,
        'opacity' => false,
        'blend_mode' => false,
        'gradient_handle_positions' => false,
        'gradient_stops' => false,
        'scale_mode' => false,
        'image_ref' => false,
        'image_transform' => false,
        'scaling_factor' => false,
        'filters' => false,
        'rotation' => false,
        'gif_ref' => false,
        'source_node_id' => false,
        'tile_type' => false,
        'spacing' => false,
        'horizontal_alignment' => false,
        'vertical_alignment' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'color' => 'color',
        'bound_variables' => 'boundVariables',
        'visible' => 'visible',
        'opacity' => 'opacity',
        'blend_mode' => 'blendMode',
        'gradient_handle_positions' => 'gradientHandlePositions',
        'gradient_stops' => 'gradientStops',
        'scale_mode' => 'scaleMode',
        'image_ref' => 'imageRef',
        'image_transform' => 'imageTransform',
        'scaling_factor' => 'scalingFactor',
        'filters' => 'filters',
        'rotation' => 'rotation',
        'gif_ref' => 'gifRef',
        'source_node_id' => 'sourceNodeId',
        'tile_type' => 'tileType',
        'spacing' => 'spacing',
        'horizontal_alignment' => 'horizontalAlignment',
        'vertical_alignment' => 'verticalAlignment'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'color' => 'setColor',
        'bound_variables' => 'setBoundVariables',
        'visible' => 'setVisible',
        'opacity' => 'setOpacity',
        'blend_mode' => 'setBlendMode',
        'gradient_handle_positions' => 'setGradientHandlePositions',
        'gradient_stops' => 'setGradientStops',
        'scale_mode' => 'setScaleMode',
        'image_ref' => 'setImageRef',
        'image_transform' => 'setImageTransform',
        'scaling_factor' => 'setScalingFactor',
        'filters' => 'setFilters',
        'rotation' => 'setRotation',
        'gif_ref' => 'setGifRef',
        'source_node_id' => 'setSourceNodeId',
        'tile_type' => 'setTileType',
        'spacing' => 'setSpacing',
        'horizontal_alignment' => 'setHorizontalAlignment',
        'vertical_alignment' => 'setVerticalAlignment'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'color' => 'getColor',
        'bound_variables' => 'getBoundVariables',
        'visible' => 'getVisible',
        'opacity' => 'getOpacity',
        'blend_mode' => 'getBlendMode',
        'gradient_handle_positions' => 'getGradientHandlePositions',
        'gradient_stops' => 'getGradientStops',
        'scale_mode' => 'getScaleMode',
        'image_ref' => 'getImageRef',
        'image_transform' => 'getImageTransform',
        'scaling_factor' => 'getScalingFactor',
        'filters' => 'getFilters',
        'rotation' => 'getRotation',
        'gif_ref' => 'getGifRef',
        'source_node_id' => 'getSourceNodeId',
        'tile_type' => 'getTileType',
        'spacing' => 'getSpacing',
        'horizontal_alignment' => 'getHorizontalAlignment',
        'vertical_alignment' => 'getVerticalAlignment'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_SOLID = 'SOLID';
    public const TYPE_GRADIENT_LINEAR = 'GRADIENT_LINEAR';
    public const TYPE_GRADIENT_RADIAL = 'GRADIENT_RADIAL';
    public const TYPE_GRADIENT_ANGULAR = 'GRADIENT_ANGULAR';
    public const TYPE_GRADIENT_DIAMOND = 'GRADIENT_DIAMOND';
    public const TYPE_IMAGE = 'IMAGE';
    public const TYPE_PATTERN = 'PATTERN';
    public const SCALE_MODE_FILL = 'FILL';
    public const SCALE_MODE_FIT = 'FIT';
    public const SCALE_MODE_TILE = 'TILE';
    public const SCALE_MODE_STRETCH = 'STRETCH';
    public const TILE_TYPE_RECTANGULAR = 'RECTANGULAR';
    public const TILE_TYPE_HORIZONTAL_HEXAGONAL = 'HORIZONTAL_HEXAGONAL';
    public const TILE_TYPE_VERTICAL_HEXAGONAL = 'VERTICAL_HEXAGONAL';
    public const HORIZONTAL_ALIGNMENT_START = 'START';
    public const HORIZONTAL_ALIGNMENT_CENTER = 'CENTER';
    public const HORIZONTAL_ALIGNMENT_END = 'END';
    public const VERTICAL_ALIGNMENT_START = 'START';
    public const VERTICAL_ALIGNMENT_CENTER = 'CENTER';
    public const VERTICAL_ALIGNMENT_END = 'END';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_SOLID,
            self::TYPE_GRADIENT_LINEAR,
            self::TYPE_GRADIENT_RADIAL,
            self::TYPE_GRADIENT_ANGULAR,
            self::TYPE_GRADIENT_DIAMOND,
            self::TYPE_IMAGE,
            self::TYPE_PATTERN,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScaleModeAllowableValues()
    {
        return [
            self::SCALE_MODE_FILL,
            self::SCALE_MODE_FIT,
            self::SCALE_MODE_TILE,
            self::SCALE_MODE_STRETCH,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTileTypeAllowableValues()
    {
        return [
            self::TILE_TYPE_RECTANGULAR,
            self::TILE_TYPE_HORIZONTAL_HEXAGONAL,
            self::TILE_TYPE_VERTICAL_HEXAGONAL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getHorizontalAlignmentAllowableValues()
    {
        return [
            self::HORIZONTAL_ALIGNMENT_START,
            self::HORIZONTAL_ALIGNMENT_CENTER,
            self::HORIZONTAL_ALIGNMENT_END,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getVerticalAlignmentAllowableValues()
    {
        return [
            self::VERTICAL_ALIGNMENT_START,
            self::VERTICAL_ALIGNMENT_CENTER,
            self::VERTICAL_ALIGNMENT_END,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('color', $data ?? [], null);
        $this->setIfExists('bound_variables', $data ?? [], null);
        $this->setIfExists('visible', $data ?? [], true);
        $this->setIfExists('opacity', $data ?? [], 1);
        $this->setIfExists('blend_mode', $data ?? [], null);
        $this->setIfExists('gradient_handle_positions', $data ?? [], null);
        $this->setIfExists('gradient_stops', $data ?? [], null);
        $this->setIfExists('scale_mode', $data ?? [], null);
        $this->setIfExists('image_ref', $data ?? [], null);
        $this->setIfExists('image_transform', $data ?? [], null);
        $this->setIfExists('scaling_factor', $data ?? [], null);
        $this->setIfExists('filters', $data ?? [], null);
        $this->setIfExists('rotation', $data ?? [], 0);
        $this->setIfExists('gif_ref', $data ?? [], null);
        $this->setIfExists('source_node_id', $data ?? [], null);
        $this->setIfExists('tile_type', $data ?? [], null);
        $this->setIfExists('spacing', $data ?? [], null);
        $this->setIfExists('horizontal_alignment', $data ?? [], null);
        $this->setIfExists('vertical_alignment', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['color'] === null) {
            $invalidProperties[] = "'color' can't be null";
        }
        if (!is_null($this->container['opacity']) && ($this->container['opacity'] > 1)) {
            $invalidProperties[] = "invalid value for 'opacity', must be smaller than or equal to 1.";
        }

        if (!is_null($this->container['opacity']) && ($this->container['opacity'] < 0)) {
            $invalidProperties[] = "invalid value for 'opacity', must be bigger than or equal to 0.";
        }

        if ($this->container['blend_mode'] === null) {
            $invalidProperties[] = "'blend_mode' can't be null";
        }
        if ($this->container['gradient_handle_positions'] === null) {
            $invalidProperties[] = "'gradient_handle_positions' can't be null";
        }
        if ($this->container['gradient_stops'] === null) {
            $invalidProperties[] = "'gradient_stops' can't be null";
        }
        if ($this->container['scale_mode'] === null) {
            $invalidProperties[] = "'scale_mode' can't be null";
        }
        $allowedValues = $this->getScaleModeAllowableValues();
        if (!is_null($this->container['scale_mode']) && !in_array($this->container['scale_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scale_mode', must be one of '%s'",
                $this->container['scale_mode'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['image_ref'] === null) {
            $invalidProperties[] = "'image_ref' can't be null";
        }
        if (!is_null($this->container['image_transform']) && (count($this->container['image_transform']) > 2)) {
            $invalidProperties[] = "invalid value for 'image_transform', number of items must be less than or equal to 2.";
        }

        if (!is_null($this->container['image_transform']) && (count($this->container['image_transform']) < 2)) {
            $invalidProperties[] = "invalid value for 'image_transform', number of items must be greater than or equal to 2.";
        }

        if ($this->container['scaling_factor'] === null) {
            $invalidProperties[] = "'scaling_factor' can't be null";
        }
        if ($this->container['source_node_id'] === null) {
            $invalidProperties[] = "'source_node_id' can't be null";
        }
        if ($this->container['tile_type'] === null) {
            $invalidProperties[] = "'tile_type' can't be null";
        }
        $allowedValues = $this->getTileTypeAllowableValues();
        if (!is_null($this->container['tile_type']) && !in_array($this->container['tile_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'tile_type', must be one of '%s'",
                $this->container['tile_type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['spacing'] === null) {
            $invalidProperties[] = "'spacing' can't be null";
        }
        if ($this->container['horizontal_alignment'] === null) {
            $invalidProperties[] = "'horizontal_alignment' can't be null";
        }
        $allowedValues = $this->getHorizontalAlignmentAllowableValues();
        if (!is_null($this->container['horizontal_alignment']) && !in_array($this->container['horizontal_alignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'horizontal_alignment', must be one of '%s'",
                $this->container['horizontal_alignment'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['vertical_alignment'] === null) {
            $invalidProperties[] = "'vertical_alignment' can't be null";
        }
        $allowedValues = $this->getVerticalAlignmentAllowableValues();
        if (!is_null($this->container['vertical_alignment']) && !in_array($this->container['vertical_alignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'vertical_alignment', must be one of '%s'",
                $this->container['vertical_alignment'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type The string literal \"SOLID\" representing the paint's type. Always check the `type` before reading other properties.
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets color
     *
     * @return \OpenAPI\Client\Model\RGBA
     */
    public function getColor()
    {
        return $this->container['color'];
    }

    /**
     * Sets color
     *
     * @param \OpenAPI\Client\Model\RGBA $color Solid color of the paint
     *
     * @return self
     */
    public function setColor($color)
    {
        if (is_null($color)) {
            throw new \InvalidArgumentException('non-nullable color cannot be null');
        }
        $this->container['color'] = $color;

        return $this;
    }

    /**
     * Gets bound_variables
     *
     * @return \OpenAPI\Client\Model\SolidPaintAllOfBoundVariables|null
     */
    public function getBoundVariables()
    {
        return $this->container['bound_variables'];
    }

    /**
     * Sets bound_variables
     *
     * @param \OpenAPI\Client\Model\SolidPaintAllOfBoundVariables|null $bound_variables bound_variables
     *
     * @return self
     */
    public function setBoundVariables($bound_variables)
    {
        if (is_null($bound_variables)) {
            throw new \InvalidArgumentException('non-nullable bound_variables cannot be null');
        }
        $this->container['bound_variables'] = $bound_variables;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible Is the paint enabled?
     *
     * @return self
     */
    public function setVisible($visible)
    {
        if (is_null($visible)) {
            throw new \InvalidArgumentException('non-nullable visible cannot be null');
        }
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets opacity
     *
     * @return float|null
     */
    public function getOpacity()
    {
        return $this->container['opacity'];
    }

    /**
     * Sets opacity
     *
     * @param float|null $opacity Overall opacity of paint (colors within the paint can also have opacity values which would blend with this)
     *
     * @return self
     */
    public function setOpacity($opacity)
    {
        if (is_null($opacity)) {
            throw new \InvalidArgumentException('non-nullable opacity cannot be null');
        }

        if (($opacity > 1)) {
            throw new \InvalidArgumentException('invalid value for $opacity when calling Paint., must be smaller than or equal to 1.');
        }
        if (($opacity < 0)) {
            throw new \InvalidArgumentException('invalid value for $opacity when calling Paint., must be bigger than or equal to 0.');
        }

        $this->container['opacity'] = $opacity;

        return $this;
    }

    /**
     * Gets blend_mode
     *
     * @return \OpenAPI\Client\Model\BlendMode
     */
    public function getBlendMode()
    {
        return $this->container['blend_mode'];
    }

    /**
     * Sets blend_mode
     *
     * @param \OpenAPI\Client\Model\BlendMode $blend_mode How this node blends with nodes behind it in the scene
     *
     * @return self
     */
    public function setBlendMode($blend_mode)
    {
        if (is_null($blend_mode)) {
            throw new \InvalidArgumentException('non-nullable blend_mode cannot be null');
        }
        $this->container['blend_mode'] = $blend_mode;

        return $this;
    }

    /**
     * Gets gradient_handle_positions
     *
     * @return \OpenAPI\Client\Model\Vector[]
     */
    public function getGradientHandlePositions()
    {
        return $this->container['gradient_handle_positions'];
    }

    /**
     * Sets gradient_handle_positions
     *
     * @param \OpenAPI\Client\Model\Vector[] $gradient_handle_positions This field contains three vectors, each of which are a position in normalized object space (normalized object space is if the top left corner of the bounding box of the object is (0, 0) and the bottom right is (1,1)). The first position corresponds to the start of the gradient (value 0 for the purposes of calculating gradient stops), the second position is the end of the gradient (value 1), and the third handle position determines the width of the gradient.
     *
     * @return self
     */
    public function setGradientHandlePositions($gradient_handle_positions)
    {
        if (is_null($gradient_handle_positions)) {
            throw new \InvalidArgumentException('non-nullable gradient_handle_positions cannot be null');
        }
        $this->container['gradient_handle_positions'] = $gradient_handle_positions;

        return $this;
    }

    /**
     * Gets gradient_stops
     *
     * @return \OpenAPI\Client\Model\ColorStop[]
     */
    public function getGradientStops()
    {
        return $this->container['gradient_stops'];
    }

    /**
     * Sets gradient_stops
     *
     * @param \OpenAPI\Client\Model\ColorStop[] $gradient_stops Positions of key points along the gradient axis with the colors anchored there. Colors along the gradient are interpolated smoothly between neighboring gradient stops.
     *
     * @return self
     */
    public function setGradientStops($gradient_stops)
    {
        if (is_null($gradient_stops)) {
            throw new \InvalidArgumentException('non-nullable gradient_stops cannot be null');
        }
        $this->container['gradient_stops'] = $gradient_stops;

        return $this;
    }

    /**
     * Gets scale_mode
     *
     * @return string
     */
    public function getScaleMode()
    {
        return $this->container['scale_mode'];
    }

    /**
     * Sets scale_mode
     *
     * @param string $scale_mode Image scaling mode.
     *
     * @return self
     */
    public function setScaleMode($scale_mode)
    {
        if (is_null($scale_mode)) {
            throw new \InvalidArgumentException('non-nullable scale_mode cannot be null');
        }
        $allowedValues = $this->getScaleModeAllowableValues();
        if (!in_array($scale_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scale_mode', must be one of '%s'",
                    $scale_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scale_mode'] = $scale_mode;

        return $this;
    }

    /**
     * Gets image_ref
     *
     * @return string
     */
    public function getImageRef()
    {
        return $this->container['image_ref'];
    }

    /**
     * Sets image_ref
     *
     * @param string $image_ref A reference to an image embedded in this node. To download the image using this reference, use the `GET file images` endpoint to retrieve the mapping from image references to image URLs.
     *
     * @return self
     */
    public function setImageRef($image_ref)
    {
        if (is_null($image_ref)) {
            throw new \InvalidArgumentException('non-nullable image_ref cannot be null');
        }
        $this->container['image_ref'] = $image_ref;

        return $this;
    }

    /**
     * Gets image_transform
     *
     * @return float[][]|null
     */
    public function getImageTransform()
    {
        return $this->container['image_transform'];
    }

    /**
     * Sets image_transform
     *
     * @param float[][]|null $image_transform A transformation matrix is standard way in computer graphics to represent translation and rotation. These are the top two rows of a 3x3 matrix. The bottom row of the matrix is assumed to be [0, 0, 1]. This is known as an affine transform and is enough to represent translation, rotation, and skew.  The identity transform is [[1, 0, 0], [0, 1, 0]].  A translation matrix will typically look like:  ``` [[1, 0, tx],   [0, 1, ty]] ```  and a rotation matrix will typically look like:  ``` [[cos(angle), sin(angle), 0],   [-sin(angle), cos(angle), 0]] ```  Another way to think about this transform is as three vectors:  - The x axis (t[0][0], t[1][0]) - The y axis (t[0][1], t[1][1]) - The translation offset (t[0][2], t[1][2])  The most common usage of the Transform matrix is the `relativeTransform property`. This particular usage of the matrix has a few additional restrictions. The translation offset can take on any value but we do enforce that the axis vectors are unit vectors (i.e. have length 1). The axes are not required to be at 90° angles to each other.
     *
     * @return self
     */
    public function setImageTransform($image_transform)
    {
        if (is_null($image_transform)) {
            throw new \InvalidArgumentException('non-nullable image_transform cannot be null');
        }

        if ((count($image_transform) > 2)) {
            throw new \InvalidArgumentException('invalid value for $image_transform when calling Paint., number of items must be less than or equal to 2.');
        }
        if ((count($image_transform) < 2)) {
            throw new \InvalidArgumentException('invalid length for $image_transform when calling Paint., number of items must be greater than or equal to 2.');
        }
        $this->container['image_transform'] = $image_transform;

        return $this;
    }

    /**
     * Gets scaling_factor
     *
     * @return float
     */
    public function getScalingFactor()
    {
        return $this->container['scaling_factor'];
    }

    /**
     * Sets scaling_factor
     *
     * @param float $scaling_factor The scaling factor for the pattern
     *
     * @return self
     */
    public function setScalingFactor($scaling_factor)
    {
        if (is_null($scaling_factor)) {
            throw new \InvalidArgumentException('non-nullable scaling_factor cannot be null');
        }
        $this->container['scaling_factor'] = $scaling_factor;

        return $this;
    }

    /**
     * Gets filters
     *
     * @return \OpenAPI\Client\Model\ImageFilters|null
     */
    public function getFilters()
    {
        return $this->container['filters'];
    }

    /**
     * Sets filters
     *
     * @param \OpenAPI\Client\Model\ImageFilters|null $filters Defines what image filters have been applied to this paint, if any. If this property is not defined, no filters have been applied.
     *
     * @return self
     */
    public function setFilters($filters)
    {
        if (is_null($filters)) {
            throw new \InvalidArgumentException('non-nullable filters cannot be null');
        }
        $this->container['filters'] = $filters;

        return $this;
    }

    /**
     * Gets rotation
     *
     * @return float|null
     */
    public function getRotation()
    {
        return $this->container['rotation'];
    }

    /**
     * Sets rotation
     *
     * @param float|null $rotation Image rotation, in degrees.
     *
     * @return self
     */
    public function setRotation($rotation)
    {
        if (is_null($rotation)) {
            throw new \InvalidArgumentException('non-nullable rotation cannot be null');
        }
        $this->container['rotation'] = $rotation;

        return $this;
    }

    /**
     * Gets gif_ref
     *
     * @return string|null
     */
    public function getGifRef()
    {
        return $this->container['gif_ref'];
    }

    /**
     * Sets gif_ref
     *
     * @param string|null $gif_ref A reference to an animated GIF embedded in this node. To download the image using this reference, use the `GET file images` endpoint to retrieve the mapping from image references to image URLs.
     *
     * @return self
     */
    public function setGifRef($gif_ref)
    {
        if (is_null($gif_ref)) {
            throw new \InvalidArgumentException('non-nullable gif_ref cannot be null');
        }
        $this->container['gif_ref'] = $gif_ref;

        return $this;
    }

    /**
     * Gets source_node_id
     *
     * @return string
     */
    public function getSourceNodeId()
    {
        return $this->container['source_node_id'];
    }

    /**
     * Sets source_node_id
     *
     * @param string $source_node_id The node id of the source node for the pattern
     *
     * @return self
     */
    public function setSourceNodeId($source_node_id)
    {
        if (is_null($source_node_id)) {
            throw new \InvalidArgumentException('non-nullable source_node_id cannot be null');
        }
        $this->container['source_node_id'] = $source_node_id;

        return $this;
    }

    /**
     * Gets tile_type
     *
     * @return string
     */
    public function getTileType()
    {
        return $this->container['tile_type'];
    }

    /**
     * Sets tile_type
     *
     * @param string $tile_type The tile type for the pattern
     *
     * @return self
     */
    public function setTileType($tile_type)
    {
        if (is_null($tile_type)) {
            throw new \InvalidArgumentException('non-nullable tile_type cannot be null');
        }
        $allowedValues = $this->getTileTypeAllowableValues();
        if (!in_array($tile_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'tile_type', must be one of '%s'",
                    $tile_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tile_type'] = $tile_type;

        return $this;
    }

    /**
     * Gets spacing
     *
     * @return \OpenAPI\Client\Model\Vector
     */
    public function getSpacing()
    {
        return $this->container['spacing'];
    }

    /**
     * Sets spacing
     *
     * @param \OpenAPI\Client\Model\Vector $spacing The spacing for the pattern
     *
     * @return self
     */
    public function setSpacing($spacing)
    {
        if (is_null($spacing)) {
            throw new \InvalidArgumentException('non-nullable spacing cannot be null');
        }
        $this->container['spacing'] = $spacing;

        return $this;
    }

    /**
     * Gets horizontal_alignment
     *
     * @return string
     */
    public function getHorizontalAlignment()
    {
        return $this->container['horizontal_alignment'];
    }

    /**
     * Sets horizontal_alignment
     *
     * @param string $horizontal_alignment The horizontal alignment for the pattern
     *
     * @return self
     */
    public function setHorizontalAlignment($horizontal_alignment)
    {
        if (is_null($horizontal_alignment)) {
            throw new \InvalidArgumentException('non-nullable horizontal_alignment cannot be null');
        }
        $allowedValues = $this->getHorizontalAlignmentAllowableValues();
        if (!in_array($horizontal_alignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'horizontal_alignment', must be one of '%s'",
                    $horizontal_alignment,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['horizontal_alignment'] = $horizontal_alignment;

        return $this;
    }

    /**
     * Gets vertical_alignment
     *
     * @return string
     */
    public function getVerticalAlignment()
    {
        return $this->container['vertical_alignment'];
    }

    /**
     * Sets vertical_alignment
     *
     * @param string $vertical_alignment The vertical alignment for the pattern
     *
     * @return self
     */
    public function setVerticalAlignment($vertical_alignment)
    {
        if (is_null($vertical_alignment)) {
            throw new \InvalidArgumentException('non-nullable vertical_alignment cannot be null');
        }
        $allowedValues = $this->getVerticalAlignmentAllowableValues();
        if (!in_array($vertical_alignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'vertical_alignment', must be one of '%s'",
                    $vertical_alignment,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['vertical_alignment'] = $vertical_alignment;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


