<?php
/**
 * SubcanvasNode
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.33.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * SubcanvasNode Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SubcanvasNode implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = 'type';

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SubcanvasNode';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'type' => 'string',
        'boolean_operation' => 'string',
        'id' => 'string',
        'name' => 'string',
        'visible' => 'bool',
        'locked' => 'bool',
        'is_fixed' => 'bool',
        'scroll_behavior' => 'string',
        'rotation' => 'float',
        'component_property_references' => 'array<string,string>',
        'plugin_data' => 'mixed',
        'shared_plugin_data' => 'mixed',
        'bound_variables' => '\OpenAPI\Client\Model\IsLayerTraitBoundVariables',
        'explicit_variable_modes' => 'array<string,string>',
        'blend_mode' => '\OpenAPI\Client\Model\BlendMode',
        'opacity' => 'float',
        'children' => '\OpenAPI\Client\Model\SubcanvasNode[]',
        'absolute_bounding_box' => '\OpenAPI\Client\Model\Rectangle',
        'absolute_render_bounds' => '\OpenAPI\Client\Model\Rectangle',
        'preserve_ratio' => 'bool',
        'constraints' => '\OpenAPI\Client\Model\LayoutConstraint',
        'relative_transform' => 'float[][]',
        'size' => '\OpenAPI\Client\Model\Vector',
        'layout_align' => 'string',
        'layout_grow' => 'float',
        'layout_positioning' => 'string',
        'min_width' => 'float',
        'max_width' => 'float',
        'min_height' => 'float',
        'max_height' => 'float',
        'layout_sizing_horizontal' => 'string',
        'layout_sizing_vertical' => 'string',
        'grid_row_count' => 'float',
        'grid_column_count' => 'float',
        'grid_row_gap' => 'float',
        'grid_column_gap' => 'float',
        'grid_columns_sizing' => 'string',
        'grid_rows_sizing' => 'string',
        'grid_child_horizontal_align' => 'string',
        'grid_child_vertical_align' => 'string',
        'grid_row_span' => 'float',
        'grid_column_span' => 'float',
        'grid_row_anchor_index' => 'float',
        'grid_column_anchor_index' => 'float',
        'fills' => '\OpenAPI\Client\Model\Paint[]',
        'styles' => 'array<string,string>',
        'strokes' => '\OpenAPI\Client\Model\Paint[]',
        'stroke_weight' => 'float',
        'stroke_align' => 'string',
        'stroke_join' => 'string',
        'stroke_dashes' => 'float[]',
        'fill_override_table' => 'array<string,\OpenAPI\Client\Model\HasGeometryTraitAllOfFillOverrideTable>',
        'fill_geometry' => '\OpenAPI\Client\Model\Path[]',
        'stroke_geometry' => '\OpenAPI\Client\Model\Path[]',
        'stroke_cap' => 'string',
        'stroke_miter_angle' => 'float',
        'export_settings' => '\OpenAPI\Client\Model\ExportSetting[]',
        'effects' => '\OpenAPI\Client\Model\Effect[]',
        'is_mask' => 'bool',
        'mask_type' => 'string',
        'is_mask_outline' => 'bool',
        'transition_node_id' => 'string',
        'transition_duration' => 'float',
        'transition_easing' => '\OpenAPI\Client\Model\EasingType',
        'interactions' => '\OpenAPI\Client\Model\Interaction[]',
        'clips_content' => 'bool',
        'background' => '\OpenAPI\Client\Model\Paint[]',
        'background_color' => '\OpenAPI\Client\Model\RGBA',
        'layout_grids' => '\OpenAPI\Client\Model\LayoutGrid[]',
        'overflow_direction' => 'string',
        'layout_mode' => 'string',
        'primary_axis_sizing_mode' => 'string',
        'counter_axis_sizing_mode' => 'string',
        'primary_axis_align_items' => 'string',
        'counter_axis_align_items' => 'string',
        'padding_left' => 'float',
        'padding_right' => 'float',
        'padding_top' => 'float',
        'padding_bottom' => 'float',
        'item_spacing' => 'float',
        'item_reverse_z_index' => 'bool',
        'strokes_included_in_layout' => 'bool',
        'layout_wrap' => 'string',
        'counter_axis_spacing' => 'float',
        'counter_axis_align_content' => 'string',
        'corner_radius' => 'float',
        'corner_smoothing' => 'float',
        'rectangle_corner_radii' => 'float[]',
        'individual_stroke_weights' => '\OpenAPI\Client\Model\StrokeWeights',
        'dev_status' => '\OpenAPI\Client\Model\DevStatusTraitDevStatus',
        'component_property_definitions' => 'array<string,\OpenAPI\Client\Model\ComponentPropertyDefinition>',
        'connector_start' => '\OpenAPI\Client\Model\ConnectorEndpoint',
        'connector_end' => '\OpenAPI\Client\Model\ConnectorEndpoint',
        'connector_start_stroke_cap' => 'string',
        'connector_end_stroke_cap' => 'string',
        'connector_line_type' => '\OpenAPI\Client\Model\ConnectorLineType',
        'text_background' => '\OpenAPI\Client\Model\ConnectorTextBackground',
        'characters' => 'string',
        'arc_data' => '\OpenAPI\Client\Model\ArcData',
        'component_id' => 'string',
        'is_exposed_instance' => 'bool',
        'exposed_instances' => 'string[]',
        'component_properties' => 'array<string,\OpenAPI\Client\Model\ComponentProperty>',
        'overrides' => '\OpenAPI\Client\Model\Overrides[]',
        'section_contents_hidden' => 'bool',
        'shape_type' => '\OpenAPI\Client\Model\ShapeType',
        'author_visible' => 'bool',
        'style' => '\OpenAPI\Client\Model\TextPathTypeStyle',
        'character_style_overrides' => 'float[]',
        'layout_version' => 'float',
        'style_override_table' => 'array<string,\OpenAPI\Client\Model\TextPathTypeStyle>',
        'line_types' => 'string[]',
        'line_indentations' => 'float[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'type' => null,
        'boolean_operation' => null,
        'id' => null,
        'name' => null,
        'visible' => null,
        'locked' => null,
        'is_fixed' => null,
        'scroll_behavior' => null,
        'rotation' => null,
        'component_property_references' => null,
        'plugin_data' => null,
        'shared_plugin_data' => null,
        'bound_variables' => null,
        'explicit_variable_modes' => null,
        'blend_mode' => null,
        'opacity' => null,
        'children' => null,
        'absolute_bounding_box' => null,
        'absolute_render_bounds' => null,
        'preserve_ratio' => null,
        'constraints' => null,
        'relative_transform' => null,
        'size' => null,
        'layout_align' => null,
        'layout_grow' => null,
        'layout_positioning' => null,
        'min_width' => null,
        'max_width' => null,
        'min_height' => null,
        'max_height' => null,
        'layout_sizing_horizontal' => null,
        'layout_sizing_vertical' => null,
        'grid_row_count' => null,
        'grid_column_count' => null,
        'grid_row_gap' => null,
        'grid_column_gap' => null,
        'grid_columns_sizing' => null,
        'grid_rows_sizing' => null,
        'grid_child_horizontal_align' => null,
        'grid_child_vertical_align' => null,
        'grid_row_span' => null,
        'grid_column_span' => null,
        'grid_row_anchor_index' => null,
        'grid_column_anchor_index' => null,
        'fills' => null,
        'styles' => null,
        'strokes' => null,
        'stroke_weight' => null,
        'stroke_align' => null,
        'stroke_join' => null,
        'stroke_dashes' => null,
        'fill_override_table' => null,
        'fill_geometry' => null,
        'stroke_geometry' => null,
        'stroke_cap' => null,
        'stroke_miter_angle' => null,
        'export_settings' => null,
        'effects' => null,
        'is_mask' => null,
        'mask_type' => null,
        'is_mask_outline' => null,
        'transition_node_id' => null,
        'transition_duration' => null,
        'transition_easing' => null,
        'interactions' => null,
        'clips_content' => null,
        'background' => null,
        'background_color' => null,
        'layout_grids' => null,
        'overflow_direction' => null,
        'layout_mode' => null,
        'primary_axis_sizing_mode' => null,
        'counter_axis_sizing_mode' => null,
        'primary_axis_align_items' => null,
        'counter_axis_align_items' => null,
        'padding_left' => null,
        'padding_right' => null,
        'padding_top' => null,
        'padding_bottom' => null,
        'item_spacing' => null,
        'item_reverse_z_index' => null,
        'strokes_included_in_layout' => null,
        'layout_wrap' => null,
        'counter_axis_spacing' => null,
        'counter_axis_align_content' => null,
        'corner_radius' => null,
        'corner_smoothing' => null,
        'rectangle_corner_radii' => null,
        'individual_stroke_weights' => null,
        'dev_status' => null,
        'component_property_definitions' => null,
        'connector_start' => null,
        'connector_end' => null,
        'connector_start_stroke_cap' => null,
        'connector_end_stroke_cap' => null,
        'connector_line_type' => null,
        'text_background' => null,
        'characters' => null,
        'arc_data' => null,
        'component_id' => null,
        'is_exposed_instance' => null,
        'exposed_instances' => null,
        'component_properties' => null,
        'overrides' => null,
        'section_contents_hidden' => null,
        'shape_type' => null,
        'author_visible' => null,
        'style' => null,
        'character_style_overrides' => null,
        'layout_version' => null,
        'style_override_table' => null,
        'line_types' => null,
        'line_indentations' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'type' => false,
        'boolean_operation' => false,
        'id' => false,
        'name' => false,
        'visible' => false,
        'locked' => false,
        'is_fixed' => false,
        'scroll_behavior' => false,
        'rotation' => false,
        'component_property_references' => false,
        'plugin_data' => true,
        'shared_plugin_data' => true,
        'bound_variables' => false,
        'explicit_variable_modes' => false,
        'blend_mode' => false,
        'opacity' => false,
        'children' => false,
        'absolute_bounding_box' => false,
        'absolute_render_bounds' => false,
        'preserve_ratio' => false,
        'constraints' => false,
        'relative_transform' => false,
        'size' => false,
        'layout_align' => false,
        'layout_grow' => false,
        'layout_positioning' => false,
        'min_width' => false,
        'max_width' => false,
        'min_height' => false,
        'max_height' => false,
        'layout_sizing_horizontal' => false,
        'layout_sizing_vertical' => false,
        'grid_row_count' => false,
        'grid_column_count' => false,
        'grid_row_gap' => false,
        'grid_column_gap' => false,
        'grid_columns_sizing' => false,
        'grid_rows_sizing' => false,
        'grid_child_horizontal_align' => false,
        'grid_child_vertical_align' => false,
        'grid_row_span' => false,
        'grid_column_span' => false,
        'grid_row_anchor_index' => false,
        'grid_column_anchor_index' => false,
        'fills' => false,
        'styles' => false,
        'strokes' => false,
        'stroke_weight' => false,
        'stroke_align' => false,
        'stroke_join' => false,
        'stroke_dashes' => false,
        'fill_override_table' => false,
        'fill_geometry' => false,
        'stroke_geometry' => false,
        'stroke_cap' => false,
        'stroke_miter_angle' => false,
        'export_settings' => false,
        'effects' => false,
        'is_mask' => false,
        'mask_type' => false,
        'is_mask_outline' => false,
        'transition_node_id' => false,
        'transition_duration' => false,
        'transition_easing' => false,
        'interactions' => false,
        'clips_content' => false,
        'background' => false,
        'background_color' => false,
        'layout_grids' => false,
        'overflow_direction' => false,
        'layout_mode' => false,
        'primary_axis_sizing_mode' => false,
        'counter_axis_sizing_mode' => false,
        'primary_axis_align_items' => false,
        'counter_axis_align_items' => false,
        'padding_left' => false,
        'padding_right' => false,
        'padding_top' => false,
        'padding_bottom' => false,
        'item_spacing' => false,
        'item_reverse_z_index' => false,
        'strokes_included_in_layout' => false,
        'layout_wrap' => false,
        'counter_axis_spacing' => false,
        'counter_axis_align_content' => false,
        'corner_radius' => false,
        'corner_smoothing' => false,
        'rectangle_corner_radii' => false,
        'individual_stroke_weights' => false,
        'dev_status' => false,
        'component_property_definitions' => false,
        'connector_start' => false,
        'connector_end' => false,
        'connector_start_stroke_cap' => false,
        'connector_end_stroke_cap' => false,
        'connector_line_type' => false,
        'text_background' => false,
        'characters' => false,
        'arc_data' => false,
        'component_id' => false,
        'is_exposed_instance' => false,
        'exposed_instances' => false,
        'component_properties' => false,
        'overrides' => false,
        'section_contents_hidden' => false,
        'shape_type' => false,
        'author_visible' => false,
        'style' => false,
        'character_style_overrides' => false,
        'layout_version' => false,
        'style_override_table' => false,
        'line_types' => false,
        'line_indentations' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'boolean_operation' => 'booleanOperation',
        'id' => 'id',
        'name' => 'name',
        'visible' => 'visible',
        'locked' => 'locked',
        'is_fixed' => 'isFixed',
        'scroll_behavior' => 'scrollBehavior',
        'rotation' => 'rotation',
        'component_property_references' => 'componentPropertyReferences',
        'plugin_data' => 'pluginData',
        'shared_plugin_data' => 'sharedPluginData',
        'bound_variables' => 'boundVariables',
        'explicit_variable_modes' => 'explicitVariableModes',
        'blend_mode' => 'blendMode',
        'opacity' => 'opacity',
        'children' => 'children',
        'absolute_bounding_box' => 'absoluteBoundingBox',
        'absolute_render_bounds' => 'absoluteRenderBounds',
        'preserve_ratio' => 'preserveRatio',
        'constraints' => 'constraints',
        'relative_transform' => 'relativeTransform',
        'size' => 'size',
        'layout_align' => 'layoutAlign',
        'layout_grow' => 'layoutGrow',
        'layout_positioning' => 'layoutPositioning',
        'min_width' => 'minWidth',
        'max_width' => 'maxWidth',
        'min_height' => 'minHeight',
        'max_height' => 'maxHeight',
        'layout_sizing_horizontal' => 'layoutSizingHorizontal',
        'layout_sizing_vertical' => 'layoutSizingVertical',
        'grid_row_count' => 'gridRowCount',
        'grid_column_count' => 'gridColumnCount',
        'grid_row_gap' => 'gridRowGap',
        'grid_column_gap' => 'gridColumnGap',
        'grid_columns_sizing' => 'gridColumnsSizing',
        'grid_rows_sizing' => 'gridRowsSizing',
        'grid_child_horizontal_align' => 'gridChildHorizontalAlign',
        'grid_child_vertical_align' => 'gridChildVerticalAlign',
        'grid_row_span' => 'gridRowSpan',
        'grid_column_span' => 'gridColumnSpan',
        'grid_row_anchor_index' => 'gridRowAnchorIndex',
        'grid_column_anchor_index' => 'gridColumnAnchorIndex',
        'fills' => 'fills',
        'styles' => 'styles',
        'strokes' => 'strokes',
        'stroke_weight' => 'strokeWeight',
        'stroke_align' => 'strokeAlign',
        'stroke_join' => 'strokeJoin',
        'stroke_dashes' => 'strokeDashes',
        'fill_override_table' => 'fillOverrideTable',
        'fill_geometry' => 'fillGeometry',
        'stroke_geometry' => 'strokeGeometry',
        'stroke_cap' => 'strokeCap',
        'stroke_miter_angle' => 'strokeMiterAngle',
        'export_settings' => 'exportSettings',
        'effects' => 'effects',
        'is_mask' => 'isMask',
        'mask_type' => 'maskType',
        'is_mask_outline' => 'isMaskOutline',
        'transition_node_id' => 'transitionNodeID',
        'transition_duration' => 'transitionDuration',
        'transition_easing' => 'transitionEasing',
        'interactions' => 'interactions',
        'clips_content' => 'clipsContent',
        'background' => 'background',
        'background_color' => 'backgroundColor',
        'layout_grids' => 'layoutGrids',
        'overflow_direction' => 'overflowDirection',
        'layout_mode' => 'layoutMode',
        'primary_axis_sizing_mode' => 'primaryAxisSizingMode',
        'counter_axis_sizing_mode' => 'counterAxisSizingMode',
        'primary_axis_align_items' => 'primaryAxisAlignItems',
        'counter_axis_align_items' => 'counterAxisAlignItems',
        'padding_left' => 'paddingLeft',
        'padding_right' => 'paddingRight',
        'padding_top' => 'paddingTop',
        'padding_bottom' => 'paddingBottom',
        'item_spacing' => 'itemSpacing',
        'item_reverse_z_index' => 'itemReverseZIndex',
        'strokes_included_in_layout' => 'strokesIncludedInLayout',
        'layout_wrap' => 'layoutWrap',
        'counter_axis_spacing' => 'counterAxisSpacing',
        'counter_axis_align_content' => 'counterAxisAlignContent',
        'corner_radius' => 'cornerRadius',
        'corner_smoothing' => 'cornerSmoothing',
        'rectangle_corner_radii' => 'rectangleCornerRadii',
        'individual_stroke_weights' => 'individualStrokeWeights',
        'dev_status' => 'devStatus',
        'component_property_definitions' => 'componentPropertyDefinitions',
        'connector_start' => 'connectorStart',
        'connector_end' => 'connectorEnd',
        'connector_start_stroke_cap' => 'connectorStartStrokeCap',
        'connector_end_stroke_cap' => 'connectorEndStrokeCap',
        'connector_line_type' => 'connectorLineType',
        'text_background' => 'textBackground',
        'characters' => 'characters',
        'arc_data' => 'arcData',
        'component_id' => 'componentId',
        'is_exposed_instance' => 'isExposedInstance',
        'exposed_instances' => 'exposedInstances',
        'component_properties' => 'componentProperties',
        'overrides' => 'overrides',
        'section_contents_hidden' => 'sectionContentsHidden',
        'shape_type' => 'shapeType',
        'author_visible' => 'authorVisible',
        'style' => 'style',
        'character_style_overrides' => 'characterStyleOverrides',
        'layout_version' => 'layoutVersion',
        'style_override_table' => 'styleOverrideTable',
        'line_types' => 'lineTypes',
        'line_indentations' => 'lineIndentations'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'boolean_operation' => 'setBooleanOperation',
        'id' => 'setId',
        'name' => 'setName',
        'visible' => 'setVisible',
        'locked' => 'setLocked',
        'is_fixed' => 'setIsFixed',
        'scroll_behavior' => 'setScrollBehavior',
        'rotation' => 'setRotation',
        'component_property_references' => 'setComponentPropertyReferences',
        'plugin_data' => 'setPluginData',
        'shared_plugin_data' => 'setSharedPluginData',
        'bound_variables' => 'setBoundVariables',
        'explicit_variable_modes' => 'setExplicitVariableModes',
        'blend_mode' => 'setBlendMode',
        'opacity' => 'setOpacity',
        'children' => 'setChildren',
        'absolute_bounding_box' => 'setAbsoluteBoundingBox',
        'absolute_render_bounds' => 'setAbsoluteRenderBounds',
        'preserve_ratio' => 'setPreserveRatio',
        'constraints' => 'setConstraints',
        'relative_transform' => 'setRelativeTransform',
        'size' => 'setSize',
        'layout_align' => 'setLayoutAlign',
        'layout_grow' => 'setLayoutGrow',
        'layout_positioning' => 'setLayoutPositioning',
        'min_width' => 'setMinWidth',
        'max_width' => 'setMaxWidth',
        'min_height' => 'setMinHeight',
        'max_height' => 'setMaxHeight',
        'layout_sizing_horizontal' => 'setLayoutSizingHorizontal',
        'layout_sizing_vertical' => 'setLayoutSizingVertical',
        'grid_row_count' => 'setGridRowCount',
        'grid_column_count' => 'setGridColumnCount',
        'grid_row_gap' => 'setGridRowGap',
        'grid_column_gap' => 'setGridColumnGap',
        'grid_columns_sizing' => 'setGridColumnsSizing',
        'grid_rows_sizing' => 'setGridRowsSizing',
        'grid_child_horizontal_align' => 'setGridChildHorizontalAlign',
        'grid_child_vertical_align' => 'setGridChildVerticalAlign',
        'grid_row_span' => 'setGridRowSpan',
        'grid_column_span' => 'setGridColumnSpan',
        'grid_row_anchor_index' => 'setGridRowAnchorIndex',
        'grid_column_anchor_index' => 'setGridColumnAnchorIndex',
        'fills' => 'setFills',
        'styles' => 'setStyles',
        'strokes' => 'setStrokes',
        'stroke_weight' => 'setStrokeWeight',
        'stroke_align' => 'setStrokeAlign',
        'stroke_join' => 'setStrokeJoin',
        'stroke_dashes' => 'setStrokeDashes',
        'fill_override_table' => 'setFillOverrideTable',
        'fill_geometry' => 'setFillGeometry',
        'stroke_geometry' => 'setStrokeGeometry',
        'stroke_cap' => 'setStrokeCap',
        'stroke_miter_angle' => 'setStrokeMiterAngle',
        'export_settings' => 'setExportSettings',
        'effects' => 'setEffects',
        'is_mask' => 'setIsMask',
        'mask_type' => 'setMaskType',
        'is_mask_outline' => 'setIsMaskOutline',
        'transition_node_id' => 'setTransitionNodeId',
        'transition_duration' => 'setTransitionDuration',
        'transition_easing' => 'setTransitionEasing',
        'interactions' => 'setInteractions',
        'clips_content' => 'setClipsContent',
        'background' => 'setBackground',
        'background_color' => 'setBackgroundColor',
        'layout_grids' => 'setLayoutGrids',
        'overflow_direction' => 'setOverflowDirection',
        'layout_mode' => 'setLayoutMode',
        'primary_axis_sizing_mode' => 'setPrimaryAxisSizingMode',
        'counter_axis_sizing_mode' => 'setCounterAxisSizingMode',
        'primary_axis_align_items' => 'setPrimaryAxisAlignItems',
        'counter_axis_align_items' => 'setCounterAxisAlignItems',
        'padding_left' => 'setPaddingLeft',
        'padding_right' => 'setPaddingRight',
        'padding_top' => 'setPaddingTop',
        'padding_bottom' => 'setPaddingBottom',
        'item_spacing' => 'setItemSpacing',
        'item_reverse_z_index' => 'setItemReverseZIndex',
        'strokes_included_in_layout' => 'setStrokesIncludedInLayout',
        'layout_wrap' => 'setLayoutWrap',
        'counter_axis_spacing' => 'setCounterAxisSpacing',
        'counter_axis_align_content' => 'setCounterAxisAlignContent',
        'corner_radius' => 'setCornerRadius',
        'corner_smoothing' => 'setCornerSmoothing',
        'rectangle_corner_radii' => 'setRectangleCornerRadii',
        'individual_stroke_weights' => 'setIndividualStrokeWeights',
        'dev_status' => 'setDevStatus',
        'component_property_definitions' => 'setComponentPropertyDefinitions',
        'connector_start' => 'setConnectorStart',
        'connector_end' => 'setConnectorEnd',
        'connector_start_stroke_cap' => 'setConnectorStartStrokeCap',
        'connector_end_stroke_cap' => 'setConnectorEndStrokeCap',
        'connector_line_type' => 'setConnectorLineType',
        'text_background' => 'setTextBackground',
        'characters' => 'setCharacters',
        'arc_data' => 'setArcData',
        'component_id' => 'setComponentId',
        'is_exposed_instance' => 'setIsExposedInstance',
        'exposed_instances' => 'setExposedInstances',
        'component_properties' => 'setComponentProperties',
        'overrides' => 'setOverrides',
        'section_contents_hidden' => 'setSectionContentsHidden',
        'shape_type' => 'setShapeType',
        'author_visible' => 'setAuthorVisible',
        'style' => 'setStyle',
        'character_style_overrides' => 'setCharacterStyleOverrides',
        'layout_version' => 'setLayoutVersion',
        'style_override_table' => 'setStyleOverrideTable',
        'line_types' => 'setLineTypes',
        'line_indentations' => 'setLineIndentations'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'boolean_operation' => 'getBooleanOperation',
        'id' => 'getId',
        'name' => 'getName',
        'visible' => 'getVisible',
        'locked' => 'getLocked',
        'is_fixed' => 'getIsFixed',
        'scroll_behavior' => 'getScrollBehavior',
        'rotation' => 'getRotation',
        'component_property_references' => 'getComponentPropertyReferences',
        'plugin_data' => 'getPluginData',
        'shared_plugin_data' => 'getSharedPluginData',
        'bound_variables' => 'getBoundVariables',
        'explicit_variable_modes' => 'getExplicitVariableModes',
        'blend_mode' => 'getBlendMode',
        'opacity' => 'getOpacity',
        'children' => 'getChildren',
        'absolute_bounding_box' => 'getAbsoluteBoundingBox',
        'absolute_render_bounds' => 'getAbsoluteRenderBounds',
        'preserve_ratio' => 'getPreserveRatio',
        'constraints' => 'getConstraints',
        'relative_transform' => 'getRelativeTransform',
        'size' => 'getSize',
        'layout_align' => 'getLayoutAlign',
        'layout_grow' => 'getLayoutGrow',
        'layout_positioning' => 'getLayoutPositioning',
        'min_width' => 'getMinWidth',
        'max_width' => 'getMaxWidth',
        'min_height' => 'getMinHeight',
        'max_height' => 'getMaxHeight',
        'layout_sizing_horizontal' => 'getLayoutSizingHorizontal',
        'layout_sizing_vertical' => 'getLayoutSizingVertical',
        'grid_row_count' => 'getGridRowCount',
        'grid_column_count' => 'getGridColumnCount',
        'grid_row_gap' => 'getGridRowGap',
        'grid_column_gap' => 'getGridColumnGap',
        'grid_columns_sizing' => 'getGridColumnsSizing',
        'grid_rows_sizing' => 'getGridRowsSizing',
        'grid_child_horizontal_align' => 'getGridChildHorizontalAlign',
        'grid_child_vertical_align' => 'getGridChildVerticalAlign',
        'grid_row_span' => 'getGridRowSpan',
        'grid_column_span' => 'getGridColumnSpan',
        'grid_row_anchor_index' => 'getGridRowAnchorIndex',
        'grid_column_anchor_index' => 'getGridColumnAnchorIndex',
        'fills' => 'getFills',
        'styles' => 'getStyles',
        'strokes' => 'getStrokes',
        'stroke_weight' => 'getStrokeWeight',
        'stroke_align' => 'getStrokeAlign',
        'stroke_join' => 'getStrokeJoin',
        'stroke_dashes' => 'getStrokeDashes',
        'fill_override_table' => 'getFillOverrideTable',
        'fill_geometry' => 'getFillGeometry',
        'stroke_geometry' => 'getStrokeGeometry',
        'stroke_cap' => 'getStrokeCap',
        'stroke_miter_angle' => 'getStrokeMiterAngle',
        'export_settings' => 'getExportSettings',
        'effects' => 'getEffects',
        'is_mask' => 'getIsMask',
        'mask_type' => 'getMaskType',
        'is_mask_outline' => 'getIsMaskOutline',
        'transition_node_id' => 'getTransitionNodeId',
        'transition_duration' => 'getTransitionDuration',
        'transition_easing' => 'getTransitionEasing',
        'interactions' => 'getInteractions',
        'clips_content' => 'getClipsContent',
        'background' => 'getBackground',
        'background_color' => 'getBackgroundColor',
        'layout_grids' => 'getLayoutGrids',
        'overflow_direction' => 'getOverflowDirection',
        'layout_mode' => 'getLayoutMode',
        'primary_axis_sizing_mode' => 'getPrimaryAxisSizingMode',
        'counter_axis_sizing_mode' => 'getCounterAxisSizingMode',
        'primary_axis_align_items' => 'getPrimaryAxisAlignItems',
        'counter_axis_align_items' => 'getCounterAxisAlignItems',
        'padding_left' => 'getPaddingLeft',
        'padding_right' => 'getPaddingRight',
        'padding_top' => 'getPaddingTop',
        'padding_bottom' => 'getPaddingBottom',
        'item_spacing' => 'getItemSpacing',
        'item_reverse_z_index' => 'getItemReverseZIndex',
        'strokes_included_in_layout' => 'getStrokesIncludedInLayout',
        'layout_wrap' => 'getLayoutWrap',
        'counter_axis_spacing' => 'getCounterAxisSpacing',
        'counter_axis_align_content' => 'getCounterAxisAlignContent',
        'corner_radius' => 'getCornerRadius',
        'corner_smoothing' => 'getCornerSmoothing',
        'rectangle_corner_radii' => 'getRectangleCornerRadii',
        'individual_stroke_weights' => 'getIndividualStrokeWeights',
        'dev_status' => 'getDevStatus',
        'component_property_definitions' => 'getComponentPropertyDefinitions',
        'connector_start' => 'getConnectorStart',
        'connector_end' => 'getConnectorEnd',
        'connector_start_stroke_cap' => 'getConnectorStartStrokeCap',
        'connector_end_stroke_cap' => 'getConnectorEndStrokeCap',
        'connector_line_type' => 'getConnectorLineType',
        'text_background' => 'getTextBackground',
        'characters' => 'getCharacters',
        'arc_data' => 'getArcData',
        'component_id' => 'getComponentId',
        'is_exposed_instance' => 'getIsExposedInstance',
        'exposed_instances' => 'getExposedInstances',
        'component_properties' => 'getComponentProperties',
        'overrides' => 'getOverrides',
        'section_contents_hidden' => 'getSectionContentsHidden',
        'shape_type' => 'getShapeType',
        'author_visible' => 'getAuthorVisible',
        'style' => 'getStyle',
        'character_style_overrides' => 'getCharacterStyleOverrides',
        'layout_version' => 'getLayoutVersion',
        'style_override_table' => 'getStyleOverrideTable',
        'line_types' => 'getLineTypes',
        'line_indentations' => 'getLineIndentations'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const BOOLEAN_OPERATION_UNION = 'UNION';
    public const BOOLEAN_OPERATION_INTERSECT = 'INTERSECT';
    public const BOOLEAN_OPERATION_SUBTRACT = 'SUBTRACT';
    public const BOOLEAN_OPERATION_EXCLUDE = 'EXCLUDE';
    public const SCROLL_BEHAVIOR_SCROLLS = 'SCROLLS';
    public const SCROLL_BEHAVIOR_FIXED = 'FIXED';
    public const SCROLL_BEHAVIOR_STICKY_SCROLLS = 'STICKY_SCROLLS';
    public const LAYOUT_ALIGN_INHERIT = 'INHERIT';
    public const LAYOUT_ALIGN_STRETCH = 'STRETCH';
    public const LAYOUT_ALIGN_MIN = 'MIN';
    public const LAYOUT_ALIGN_CENTER = 'CENTER';
    public const LAYOUT_ALIGN_MAX = 'MAX';
    public const LAYOUT_GROW_NUMBER_0 = 0;
    public const LAYOUT_GROW_NUMBER_1 = 1;
    public const LAYOUT_POSITIONING_AUTO = 'AUTO';
    public const LAYOUT_POSITIONING_ABSOLUTE = 'ABSOLUTE';
    public const LAYOUT_SIZING_HORIZONTAL_FIXED = 'FIXED';
    public const LAYOUT_SIZING_HORIZONTAL_HUG = 'HUG';
    public const LAYOUT_SIZING_HORIZONTAL_FILL = 'FILL';
    public const LAYOUT_SIZING_VERTICAL_FIXED = 'FIXED';
    public const LAYOUT_SIZING_VERTICAL_HUG = 'HUG';
    public const LAYOUT_SIZING_VERTICAL_FILL = 'FILL';
    public const GRID_CHILD_HORIZONTAL_ALIGN_AUTO = 'AUTO';
    public const GRID_CHILD_HORIZONTAL_ALIGN_MIN = 'MIN';
    public const GRID_CHILD_HORIZONTAL_ALIGN_CENTER = 'CENTER';
    public const GRID_CHILD_HORIZONTAL_ALIGN_MAX = 'MAX';
    public const GRID_CHILD_VERTICAL_ALIGN_AUTO = 'AUTO';
    public const GRID_CHILD_VERTICAL_ALIGN_MIN = 'MIN';
    public const GRID_CHILD_VERTICAL_ALIGN_CENTER = 'CENTER';
    public const GRID_CHILD_VERTICAL_ALIGN_MAX = 'MAX';
    public const STROKE_ALIGN_INSIDE = 'INSIDE';
    public const STROKE_ALIGN_OUTSIDE = 'OUTSIDE';
    public const STROKE_ALIGN_CENTER = 'CENTER';
    public const STROKE_JOIN_MITER = 'MITER';
    public const STROKE_JOIN_BEVEL = 'BEVEL';
    public const STROKE_JOIN_ROUND = 'ROUND';
    public const STROKE_CAP_NONE = 'NONE';
    public const STROKE_CAP_ROUND = 'ROUND';
    public const STROKE_CAP_SQUARE = 'SQUARE';
    public const STROKE_CAP_LINE_ARROW = 'LINE_ARROW';
    public const STROKE_CAP_TRIANGLE_ARROW = 'TRIANGLE_ARROW';
    public const STROKE_CAP_DIAMOND_FILLED = 'DIAMOND_FILLED';
    public const STROKE_CAP_CIRCLE_FILLED = 'CIRCLE_FILLED';
    public const STROKE_CAP_TRIANGLE_FILLED = 'TRIANGLE_FILLED';
    public const STROKE_CAP_WASHI_TAPE_1 = 'WASHI_TAPE_1';
    public const STROKE_CAP_WASHI_TAPE_2 = 'WASHI_TAPE_2';
    public const STROKE_CAP_WASHI_TAPE_3 = 'WASHI_TAPE_3';
    public const STROKE_CAP_WASHI_TAPE_4 = 'WASHI_TAPE_4';
    public const STROKE_CAP_WASHI_TAPE_5 = 'WASHI_TAPE_5';
    public const STROKE_CAP_WASHI_TAPE_6 = 'WASHI_TAPE_6';
    public const MASK_TYPE_ALPHA = 'ALPHA';
    public const MASK_TYPE_VECTOR = 'VECTOR';
    public const MASK_TYPE_LUMINANCE = 'LUMINANCE';
    public const OVERFLOW_DIRECTION_HORIZONTAL_SCROLLING = 'HORIZONTAL_SCROLLING';
    public const OVERFLOW_DIRECTION_VERTICAL_SCROLLING = 'VERTICAL_SCROLLING';
    public const OVERFLOW_DIRECTION_HORIZONTAL_AND_VERTICAL_SCROLLING = 'HORIZONTAL_AND_VERTICAL_SCROLLING';
    public const OVERFLOW_DIRECTION_NONE = 'NONE';
    public const LAYOUT_MODE_NONE = 'NONE';
    public const LAYOUT_MODE_HORIZONTAL = 'HORIZONTAL';
    public const LAYOUT_MODE_VERTICAL = 'VERTICAL';
    public const LAYOUT_MODE_GRID = 'GRID';
    public const PRIMARY_AXIS_SIZING_MODE_FIXED = 'FIXED';
    public const PRIMARY_AXIS_SIZING_MODE_AUTO = 'AUTO';
    public const COUNTER_AXIS_SIZING_MODE_FIXED = 'FIXED';
    public const COUNTER_AXIS_SIZING_MODE_AUTO = 'AUTO';
    public const PRIMARY_AXIS_ALIGN_ITEMS_MIN = 'MIN';
    public const PRIMARY_AXIS_ALIGN_ITEMS_CENTER = 'CENTER';
    public const PRIMARY_AXIS_ALIGN_ITEMS_MAX = 'MAX';
    public const PRIMARY_AXIS_ALIGN_ITEMS_SPACE_BETWEEN = 'SPACE_BETWEEN';
    public const COUNTER_AXIS_ALIGN_ITEMS_MIN = 'MIN';
    public const COUNTER_AXIS_ALIGN_ITEMS_CENTER = 'CENTER';
    public const COUNTER_AXIS_ALIGN_ITEMS_MAX = 'MAX';
    public const COUNTER_AXIS_ALIGN_ITEMS_BASELINE = 'BASELINE';
    public const LAYOUT_WRAP_NO_WRAP = 'NO_WRAP';
    public const LAYOUT_WRAP_WRAP = 'WRAP';
    public const COUNTER_AXIS_ALIGN_CONTENT_AUTO = 'AUTO';
    public const COUNTER_AXIS_ALIGN_CONTENT_SPACE_BETWEEN = 'SPACE_BETWEEN';
    public const CONNECTOR_START_STROKE_CAP_NONE = 'NONE';
    public const CONNECTOR_START_STROKE_CAP_LINE_ARROW = 'LINE_ARROW';
    public const CONNECTOR_START_STROKE_CAP_TRIANGLE_ARROW = 'TRIANGLE_ARROW';
    public const CONNECTOR_START_STROKE_CAP_DIAMOND_FILLED = 'DIAMOND_FILLED';
    public const CONNECTOR_START_STROKE_CAP_CIRCLE_FILLED = 'CIRCLE_FILLED';
    public const CONNECTOR_START_STROKE_CAP_TRIANGLE_FILLED = 'TRIANGLE_FILLED';
    public const CONNECTOR_END_STROKE_CAP_NONE = 'NONE';
    public const CONNECTOR_END_STROKE_CAP_LINE_ARROW = 'LINE_ARROW';
    public const CONNECTOR_END_STROKE_CAP_TRIANGLE_ARROW = 'TRIANGLE_ARROW';
    public const CONNECTOR_END_STROKE_CAP_DIAMOND_FILLED = 'DIAMOND_FILLED';
    public const CONNECTOR_END_STROKE_CAP_CIRCLE_FILLED = 'CIRCLE_FILLED';
    public const CONNECTOR_END_STROKE_CAP_TRIANGLE_FILLED = 'TRIANGLE_FILLED';
    public const LINE_TYPES_NONE = 'NONE';
    public const LINE_TYPES_ORDERED = 'ORDERED';
    public const LINE_TYPES_UNORDERED = 'UNORDERED';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBooleanOperationAllowableValues()
    {
        return [
            self::BOOLEAN_OPERATION_UNION,
            self::BOOLEAN_OPERATION_INTERSECT,
            self::BOOLEAN_OPERATION_SUBTRACT,
            self::BOOLEAN_OPERATION_EXCLUDE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScrollBehaviorAllowableValues()
    {
        return [
            self::SCROLL_BEHAVIOR_SCROLLS,
            self::SCROLL_BEHAVIOR_FIXED,
            self::SCROLL_BEHAVIOR_STICKY_SCROLLS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutAlignAllowableValues()
    {
        return [
            self::LAYOUT_ALIGN_INHERIT,
            self::LAYOUT_ALIGN_STRETCH,
            self::LAYOUT_ALIGN_MIN,
            self::LAYOUT_ALIGN_CENTER,
            self::LAYOUT_ALIGN_MAX,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutGrowAllowableValues()
    {
        return [
            self::LAYOUT_GROW_NUMBER_0,
            self::LAYOUT_GROW_NUMBER_1,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutPositioningAllowableValues()
    {
        return [
            self::LAYOUT_POSITIONING_AUTO,
            self::LAYOUT_POSITIONING_ABSOLUTE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutSizingHorizontalAllowableValues()
    {
        return [
            self::LAYOUT_SIZING_HORIZONTAL_FIXED,
            self::LAYOUT_SIZING_HORIZONTAL_HUG,
            self::LAYOUT_SIZING_HORIZONTAL_FILL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutSizingVerticalAllowableValues()
    {
        return [
            self::LAYOUT_SIZING_VERTICAL_FIXED,
            self::LAYOUT_SIZING_VERTICAL_HUG,
            self::LAYOUT_SIZING_VERTICAL_FILL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGridChildHorizontalAlignAllowableValues()
    {
        return [
            self::GRID_CHILD_HORIZONTAL_ALIGN_AUTO,
            self::GRID_CHILD_HORIZONTAL_ALIGN_MIN,
            self::GRID_CHILD_HORIZONTAL_ALIGN_CENTER,
            self::GRID_CHILD_HORIZONTAL_ALIGN_MAX,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGridChildVerticalAlignAllowableValues()
    {
        return [
            self::GRID_CHILD_VERTICAL_ALIGN_AUTO,
            self::GRID_CHILD_VERTICAL_ALIGN_MIN,
            self::GRID_CHILD_VERTICAL_ALIGN_CENTER,
            self::GRID_CHILD_VERTICAL_ALIGN_MAX,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStrokeAlignAllowableValues()
    {
        return [
            self::STROKE_ALIGN_INSIDE,
            self::STROKE_ALIGN_OUTSIDE,
            self::STROKE_ALIGN_CENTER,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStrokeJoinAllowableValues()
    {
        return [
            self::STROKE_JOIN_MITER,
            self::STROKE_JOIN_BEVEL,
            self::STROKE_JOIN_ROUND,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStrokeCapAllowableValues()
    {
        return [
            self::STROKE_CAP_NONE,
            self::STROKE_CAP_ROUND,
            self::STROKE_CAP_SQUARE,
            self::STROKE_CAP_LINE_ARROW,
            self::STROKE_CAP_TRIANGLE_ARROW,
            self::STROKE_CAP_DIAMOND_FILLED,
            self::STROKE_CAP_CIRCLE_FILLED,
            self::STROKE_CAP_TRIANGLE_FILLED,
            self::STROKE_CAP_WASHI_TAPE_1,
            self::STROKE_CAP_WASHI_TAPE_2,
            self::STROKE_CAP_WASHI_TAPE_3,
            self::STROKE_CAP_WASHI_TAPE_4,
            self::STROKE_CAP_WASHI_TAPE_5,
            self::STROKE_CAP_WASHI_TAPE_6,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMaskTypeAllowableValues()
    {
        return [
            self::MASK_TYPE_ALPHA,
            self::MASK_TYPE_VECTOR,
            self::MASK_TYPE_LUMINANCE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOverflowDirectionAllowableValues()
    {
        return [
            self::OVERFLOW_DIRECTION_HORIZONTAL_SCROLLING,
            self::OVERFLOW_DIRECTION_VERTICAL_SCROLLING,
            self::OVERFLOW_DIRECTION_HORIZONTAL_AND_VERTICAL_SCROLLING,
            self::OVERFLOW_DIRECTION_NONE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutModeAllowableValues()
    {
        return [
            self::LAYOUT_MODE_NONE,
            self::LAYOUT_MODE_HORIZONTAL,
            self::LAYOUT_MODE_VERTICAL,
            self::LAYOUT_MODE_GRID,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPrimaryAxisSizingModeAllowableValues()
    {
        return [
            self::PRIMARY_AXIS_SIZING_MODE_FIXED,
            self::PRIMARY_AXIS_SIZING_MODE_AUTO,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCounterAxisSizingModeAllowableValues()
    {
        return [
            self::COUNTER_AXIS_SIZING_MODE_FIXED,
            self::COUNTER_AXIS_SIZING_MODE_AUTO,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPrimaryAxisAlignItemsAllowableValues()
    {
        return [
            self::PRIMARY_AXIS_ALIGN_ITEMS_MIN,
            self::PRIMARY_AXIS_ALIGN_ITEMS_CENTER,
            self::PRIMARY_AXIS_ALIGN_ITEMS_MAX,
            self::PRIMARY_AXIS_ALIGN_ITEMS_SPACE_BETWEEN,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCounterAxisAlignItemsAllowableValues()
    {
        return [
            self::COUNTER_AXIS_ALIGN_ITEMS_MIN,
            self::COUNTER_AXIS_ALIGN_ITEMS_CENTER,
            self::COUNTER_AXIS_ALIGN_ITEMS_MAX,
            self::COUNTER_AXIS_ALIGN_ITEMS_BASELINE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutWrapAllowableValues()
    {
        return [
            self::LAYOUT_WRAP_NO_WRAP,
            self::LAYOUT_WRAP_WRAP,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCounterAxisAlignContentAllowableValues()
    {
        return [
            self::COUNTER_AXIS_ALIGN_CONTENT_AUTO,
            self::COUNTER_AXIS_ALIGN_CONTENT_SPACE_BETWEEN,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getConnectorStartStrokeCapAllowableValues()
    {
        return [
            self::CONNECTOR_START_STROKE_CAP_NONE,
            self::CONNECTOR_START_STROKE_CAP_LINE_ARROW,
            self::CONNECTOR_START_STROKE_CAP_TRIANGLE_ARROW,
            self::CONNECTOR_START_STROKE_CAP_DIAMOND_FILLED,
            self::CONNECTOR_START_STROKE_CAP_CIRCLE_FILLED,
            self::CONNECTOR_START_STROKE_CAP_TRIANGLE_FILLED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getConnectorEndStrokeCapAllowableValues()
    {
        return [
            self::CONNECTOR_END_STROKE_CAP_NONE,
            self::CONNECTOR_END_STROKE_CAP_LINE_ARROW,
            self::CONNECTOR_END_STROKE_CAP_TRIANGLE_ARROW,
            self::CONNECTOR_END_STROKE_CAP_DIAMOND_FILLED,
            self::CONNECTOR_END_STROKE_CAP_CIRCLE_FILLED,
            self::CONNECTOR_END_STROKE_CAP_TRIANGLE_FILLED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLineTypesAllowableValues()
    {
        return [
            self::LINE_TYPES_NONE,
            self::LINE_TYPES_ORDERED,
            self::LINE_TYPES_UNORDERED,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('boolean_operation', $data ?? [], null);
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('visible', $data ?? [], true);
        $this->setIfExists('locked', $data ?? [], false);
        $this->setIfExists('is_fixed', $data ?? [], false);
        $this->setIfExists('scroll_behavior', $data ?? [], 'SCROLLS');
        $this->setIfExists('rotation', $data ?? [], 0);
        $this->setIfExists('component_property_references', $data ?? [], null);
        $this->setIfExists('plugin_data', $data ?? [], null);
        $this->setIfExists('shared_plugin_data', $data ?? [], null);
        $this->setIfExists('bound_variables', $data ?? [], null);
        $this->setIfExists('explicit_variable_modes', $data ?? [], null);
        $this->setIfExists('blend_mode', $data ?? [], null);
        $this->setIfExists('opacity', $data ?? [], 1);
        $this->setIfExists('children', $data ?? [], null);
        $this->setIfExists('absolute_bounding_box', $data ?? [], null);
        $this->setIfExists('absolute_render_bounds', $data ?? [], null);
        $this->setIfExists('preserve_ratio', $data ?? [], false);
        $this->setIfExists('constraints', $data ?? [], null);
        $this->setIfExists('relative_transform', $data ?? [], null);
        $this->setIfExists('size', $data ?? [], null);
        $this->setIfExists('layout_align', $data ?? [], null);
        $this->setIfExists('layout_grow', $data ?? [], self::LAYOUT_GROW_NUMBER_0);
        $this->setIfExists('layout_positioning', $data ?? [], 'AUTO');
        $this->setIfExists('min_width', $data ?? [], 0);
        $this->setIfExists('max_width', $data ?? [], 0);
        $this->setIfExists('min_height', $data ?? [], 0);
        $this->setIfExists('max_height', $data ?? [], 0);
        $this->setIfExists('layout_sizing_horizontal', $data ?? [], null);
        $this->setIfExists('layout_sizing_vertical', $data ?? [], null);
        $this->setIfExists('grid_row_count', $data ?? [], null);
        $this->setIfExists('grid_column_count', $data ?? [], null);
        $this->setIfExists('grid_row_gap', $data ?? [], 0);
        $this->setIfExists('grid_column_gap', $data ?? [], 0);
        $this->setIfExists('grid_columns_sizing', $data ?? [], null);
        $this->setIfExists('grid_rows_sizing', $data ?? [], null);
        $this->setIfExists('grid_child_horizontal_align', $data ?? [], null);
        $this->setIfExists('grid_child_vertical_align', $data ?? [], null);
        $this->setIfExists('grid_row_span', $data ?? [], 1);
        $this->setIfExists('grid_column_span', $data ?? [], 1);
        $this->setIfExists('grid_row_anchor_index', $data ?? [], 0);
        $this->setIfExists('grid_column_anchor_index', $data ?? [], 0);
        $this->setIfExists('fills', $data ?? [], null);
        $this->setIfExists('styles', $data ?? [], null);
        $this->setIfExists('strokes', $data ?? [], null);
        $this->setIfExists('stroke_weight', $data ?? [], 1);
        $this->setIfExists('stroke_align', $data ?? [], null);
        $this->setIfExists('stroke_join', $data ?? [], 'MITER');
        $this->setIfExists('stroke_dashes', $data ?? [], null);
        $this->setIfExists('fill_override_table', $data ?? [], null);
        $this->setIfExists('fill_geometry', $data ?? [], null);
        $this->setIfExists('stroke_geometry', $data ?? [], null);
        $this->setIfExists('stroke_cap', $data ?? [], 'NONE');
        $this->setIfExists('stroke_miter_angle', $data ?? [], 28.96);
        $this->setIfExists('export_settings', $data ?? [], null);
        $this->setIfExists('effects', $data ?? [], null);
        $this->setIfExists('is_mask', $data ?? [], false);
        $this->setIfExists('mask_type', $data ?? [], null);
        $this->setIfExists('is_mask_outline', $data ?? [], false);
        $this->setIfExists('transition_node_id', $data ?? [], null);
        $this->setIfExists('transition_duration', $data ?? [], null);
        $this->setIfExists('transition_easing', $data ?? [], null);
        $this->setIfExists('interactions', $data ?? [], null);
        $this->setIfExists('clips_content', $data ?? [], null);
        $this->setIfExists('background', $data ?? [], null);
        $this->setIfExists('background_color', $data ?? [], null);
        $this->setIfExists('layout_grids', $data ?? [], null);
        $this->setIfExists('overflow_direction', $data ?? [], 'NONE');
        $this->setIfExists('layout_mode', $data ?? [], 'NONE');
        $this->setIfExists('primary_axis_sizing_mode', $data ?? [], 'AUTO');
        $this->setIfExists('counter_axis_sizing_mode', $data ?? [], 'AUTO');
        $this->setIfExists('primary_axis_align_items', $data ?? [], 'MIN');
        $this->setIfExists('counter_axis_align_items', $data ?? [], 'MIN');
        $this->setIfExists('padding_left', $data ?? [], 0);
        $this->setIfExists('padding_right', $data ?? [], 0);
        $this->setIfExists('padding_top', $data ?? [], 0);
        $this->setIfExists('padding_bottom', $data ?? [], 0);
        $this->setIfExists('item_spacing', $data ?? [], 0);
        $this->setIfExists('item_reverse_z_index', $data ?? [], false);
        $this->setIfExists('strokes_included_in_layout', $data ?? [], false);
        $this->setIfExists('layout_wrap', $data ?? [], null);
        $this->setIfExists('counter_axis_spacing', $data ?? [], null);
        $this->setIfExists('counter_axis_align_content', $data ?? [], 'AUTO');
        $this->setIfExists('corner_radius', $data ?? [], 0);
        $this->setIfExists('corner_smoothing', $data ?? [], null);
        $this->setIfExists('rectangle_corner_radii', $data ?? [], null);
        $this->setIfExists('individual_stroke_weights', $data ?? [], null);
        $this->setIfExists('dev_status', $data ?? [], null);
        $this->setIfExists('component_property_definitions', $data ?? [], null);
        $this->setIfExists('connector_start', $data ?? [], null);
        $this->setIfExists('connector_end', $data ?? [], null);
        $this->setIfExists('connector_start_stroke_cap', $data ?? [], 'NONE');
        $this->setIfExists('connector_end_stroke_cap', $data ?? [], 'NONE');
        $this->setIfExists('connector_line_type', $data ?? [], null);
        $this->setIfExists('text_background', $data ?? [], null);
        $this->setIfExists('characters', $data ?? [], null);
        $this->setIfExists('arc_data', $data ?? [], null);
        $this->setIfExists('component_id', $data ?? [], null);
        $this->setIfExists('is_exposed_instance', $data ?? [], false);
        $this->setIfExists('exposed_instances', $data ?? [], null);
        $this->setIfExists('component_properties', $data ?? [], null);
        $this->setIfExists('overrides', $data ?? [], null);
        $this->setIfExists('section_contents_hidden', $data ?? [], false);
        $this->setIfExists('shape_type', $data ?? [], null);
        $this->setIfExists('author_visible', $data ?? [], false);
        $this->setIfExists('style', $data ?? [], null);
        $this->setIfExists('character_style_overrides', $data ?? [], null);
        $this->setIfExists('layout_version', $data ?? [], null);
        $this->setIfExists('style_override_table', $data ?? [], null);
        $this->setIfExists('line_types', $data ?? [], null);
        $this->setIfExists('line_indentations', $data ?? [], null);

        // Initialize discriminator property with the model name.
        $this->container['type'] = static::$openAPIModelName;
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        if ($this->container['boolean_operation'] === null) {
            $invalidProperties[] = "'boolean_operation' can't be null";
        }
        $allowedValues = $this->getBooleanOperationAllowableValues();
        if (!is_null($this->container['boolean_operation']) && !in_array($this->container['boolean_operation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'boolean_operation', must be one of '%s'",
                $this->container['boolean_operation'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['scroll_behavior'] === null) {
            $invalidProperties[] = "'scroll_behavior' can't be null";
        }
        $allowedValues = $this->getScrollBehaviorAllowableValues();
        if (!is_null($this->container['scroll_behavior']) && !in_array($this->container['scroll_behavior'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scroll_behavior', must be one of '%s'",
                $this->container['scroll_behavior'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['blend_mode'] === null) {
            $invalidProperties[] = "'blend_mode' can't be null";
        }
        if (!is_null($this->container['opacity']) && ($this->container['opacity'] > 1)) {
            $invalidProperties[] = "invalid value for 'opacity', must be smaller than or equal to 1.";
        }

        if (!is_null($this->container['opacity']) && ($this->container['opacity'] < 0)) {
            $invalidProperties[] = "invalid value for 'opacity', must be bigger than or equal to 0.";
        }

        if ($this->container['children'] === null) {
            $invalidProperties[] = "'children' can't be null";
        }
        if ($this->container['absolute_bounding_box'] === null) {
            $invalidProperties[] = "'absolute_bounding_box' can't be null";
        }
        if ($this->container['absolute_render_bounds'] === null) {
            $invalidProperties[] = "'absolute_render_bounds' can't be null";
        }
        if (!is_null($this->container['relative_transform']) && (count($this->container['relative_transform']) > 2)) {
            $invalidProperties[] = "invalid value for 'relative_transform', number of items must be less than or equal to 2.";
        }

        if (!is_null($this->container['relative_transform']) && (count($this->container['relative_transform']) < 2)) {
            $invalidProperties[] = "invalid value for 'relative_transform', number of items must be greater than or equal to 2.";
        }

        $allowedValues = $this->getLayoutAlignAllowableValues();
        if (!is_null($this->container['layout_align']) && !in_array($this->container['layout_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_align', must be one of '%s'",
                $this->container['layout_align'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutGrowAllowableValues();
        if (!is_null($this->container['layout_grow']) && !in_array($this->container['layout_grow'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_grow', must be one of '%s'",
                $this->container['layout_grow'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutPositioningAllowableValues();
        if (!is_null($this->container['layout_positioning']) && !in_array($this->container['layout_positioning'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_positioning', must be one of '%s'",
                $this->container['layout_positioning'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutSizingHorizontalAllowableValues();
        if (!is_null($this->container['layout_sizing_horizontal']) && !in_array($this->container['layout_sizing_horizontal'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_sizing_horizontal', must be one of '%s'",
                $this->container['layout_sizing_horizontal'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutSizingVerticalAllowableValues();
        if (!is_null($this->container['layout_sizing_vertical']) && !in_array($this->container['layout_sizing_vertical'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_sizing_vertical', must be one of '%s'",
                $this->container['layout_sizing_vertical'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getGridChildHorizontalAlignAllowableValues();
        if (!is_null($this->container['grid_child_horizontal_align']) && !in_array($this->container['grid_child_horizontal_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'grid_child_horizontal_align', must be one of '%s'",
                $this->container['grid_child_horizontal_align'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getGridChildVerticalAlignAllowableValues();
        if (!is_null($this->container['grid_child_vertical_align']) && !in_array($this->container['grid_child_vertical_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'grid_child_vertical_align', must be one of '%s'",
                $this->container['grid_child_vertical_align'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['fills'] === null) {
            $invalidProperties[] = "'fills' can't be null";
        }
        $allowedValues = $this->getStrokeAlignAllowableValues();
        if (!is_null($this->container['stroke_align']) && !in_array($this->container['stroke_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'stroke_align', must be one of '%s'",
                $this->container['stroke_align'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStrokeJoinAllowableValues();
        if (!is_null($this->container['stroke_join']) && !in_array($this->container['stroke_join'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'stroke_join', must be one of '%s'",
                $this->container['stroke_join'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStrokeCapAllowableValues();
        if (!is_null($this->container['stroke_cap']) && !in_array($this->container['stroke_cap'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'stroke_cap', must be one of '%s'",
                $this->container['stroke_cap'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['effects'] === null) {
            $invalidProperties[] = "'effects' can't be null";
        }
        $allowedValues = $this->getMaskTypeAllowableValues();
        if (!is_null($this->container['mask_type']) && !in_array($this->container['mask_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'mask_type', must be one of '%s'",
                $this->container['mask_type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['clips_content'] === null) {
            $invalidProperties[] = "'clips_content' can't be null";
        }
        $allowedValues = $this->getOverflowDirectionAllowableValues();
        if (!is_null($this->container['overflow_direction']) && !in_array($this->container['overflow_direction'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'overflow_direction', must be one of '%s'",
                $this->container['overflow_direction'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutModeAllowableValues();
        if (!is_null($this->container['layout_mode']) && !in_array($this->container['layout_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_mode', must be one of '%s'",
                $this->container['layout_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPrimaryAxisSizingModeAllowableValues();
        if (!is_null($this->container['primary_axis_sizing_mode']) && !in_array($this->container['primary_axis_sizing_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'primary_axis_sizing_mode', must be one of '%s'",
                $this->container['primary_axis_sizing_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCounterAxisSizingModeAllowableValues();
        if (!is_null($this->container['counter_axis_sizing_mode']) && !in_array($this->container['counter_axis_sizing_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'counter_axis_sizing_mode', must be one of '%s'",
                $this->container['counter_axis_sizing_mode'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPrimaryAxisAlignItemsAllowableValues();
        if (!is_null($this->container['primary_axis_align_items']) && !in_array($this->container['primary_axis_align_items'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'primary_axis_align_items', must be one of '%s'",
                $this->container['primary_axis_align_items'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCounterAxisAlignItemsAllowableValues();
        if (!is_null($this->container['counter_axis_align_items']) && !in_array($this->container['counter_axis_align_items'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'counter_axis_align_items', must be one of '%s'",
                $this->container['counter_axis_align_items'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutWrapAllowableValues();
        if (!is_null($this->container['layout_wrap']) && !in_array($this->container['layout_wrap'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_wrap', must be one of '%s'",
                $this->container['layout_wrap'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCounterAxisAlignContentAllowableValues();
        if (!is_null($this->container['counter_axis_align_content']) && !in_array($this->container['counter_axis_align_content'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'counter_axis_align_content', must be one of '%s'",
                $this->container['counter_axis_align_content'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['rectangle_corner_radii']) && (count($this->container['rectangle_corner_radii']) > 4)) {
            $invalidProperties[] = "invalid value for 'rectangle_corner_radii', number of items must be less than or equal to 4.";
        }

        if (!is_null($this->container['rectangle_corner_radii']) && (count($this->container['rectangle_corner_radii']) < 4)) {
            $invalidProperties[] = "invalid value for 'rectangle_corner_radii', number of items must be greater than or equal to 4.";
        }

        if ($this->container['connector_start'] === null) {
            $invalidProperties[] = "'connector_start' can't be null";
        }
        if ($this->container['connector_end'] === null) {
            $invalidProperties[] = "'connector_end' can't be null";
        }
        if ($this->container['connector_start_stroke_cap'] === null) {
            $invalidProperties[] = "'connector_start_stroke_cap' can't be null";
        }
        $allowedValues = $this->getConnectorStartStrokeCapAllowableValues();
        if (!is_null($this->container['connector_start_stroke_cap']) && !in_array($this->container['connector_start_stroke_cap'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'connector_start_stroke_cap', must be one of '%s'",
                $this->container['connector_start_stroke_cap'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['connector_end_stroke_cap'] === null) {
            $invalidProperties[] = "'connector_end_stroke_cap' can't be null";
        }
        $allowedValues = $this->getConnectorEndStrokeCapAllowableValues();
        if (!is_null($this->container['connector_end_stroke_cap']) && !in_array($this->container['connector_end_stroke_cap'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'connector_end_stroke_cap', must be one of '%s'",
                $this->container['connector_end_stroke_cap'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['connector_line_type'] === null) {
            $invalidProperties[] = "'connector_line_type' can't be null";
        }
        if ($this->container['characters'] === null) {
            $invalidProperties[] = "'characters' can't be null";
        }
        if ($this->container['arc_data'] === null) {
            $invalidProperties[] = "'arc_data' can't be null";
        }
        if ($this->container['component_id'] === null) {
            $invalidProperties[] = "'component_id' can't be null";
        }
        if ($this->container['overrides'] === null) {
            $invalidProperties[] = "'overrides' can't be null";
        }
        if ($this->container['section_contents_hidden'] === null) {
            $invalidProperties[] = "'section_contents_hidden' can't be null";
        }
        if ($this->container['shape_type'] === null) {
            $invalidProperties[] = "'shape_type' can't be null";
        }
        if ($this->container['style'] === null) {
            $invalidProperties[] = "'style' can't be null";
        }
        if ($this->container['character_style_overrides'] === null) {
            $invalidProperties[] = "'character_style_overrides' can't be null";
        }
        if ($this->container['style_override_table'] === null) {
            $invalidProperties[] = "'style_override_table' can't be null";
        }
        if ($this->container['line_types'] === null) {
            $invalidProperties[] = "'line_types' can't be null";
        }
        if ($this->container['line_indentations'] === null) {
            $invalidProperties[] = "'line_indentations' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type The type of the node
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets boolean_operation
     *
     * @return string
     */
    public function getBooleanOperation()
    {
        return $this->container['boolean_operation'];
    }

    /**
     * Sets boolean_operation
     *
     * @param string $boolean_operation A string enum indicating the type of boolean operation applied.
     *
     * @return self
     */
    public function setBooleanOperation($boolean_operation)
    {
        if (is_null($boolean_operation)) {
            throw new \InvalidArgumentException('non-nullable boolean_operation cannot be null');
        }
        $allowedValues = $this->getBooleanOperationAllowableValues();
        if (!in_array($boolean_operation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'boolean_operation', must be one of '%s'",
                    $boolean_operation,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['boolean_operation'] = $boolean_operation;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id A string uniquely identifying this node within the document.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name given to the node by the user in the tool.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible Whether or not the node is visible on the canvas.
     *
     * @return self
     */
    public function setVisible($visible)
    {
        if (is_null($visible)) {
            throw new \InvalidArgumentException('non-nullable visible cannot be null');
        }
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets locked
     *
     * @return bool|null
     */
    public function getLocked()
    {
        return $this->container['locked'];
    }

    /**
     * Sets locked
     *
     * @param bool|null $locked If true, layer is locked and cannot be edited
     *
     * @return self
     */
    public function setLocked($locked)
    {
        if (is_null($locked)) {
            throw new \InvalidArgumentException('non-nullable locked cannot be null');
        }
        $this->container['locked'] = $locked;

        return $this;
    }

    /**
     * Gets is_fixed
     *
     * @return bool|null
     * @deprecated
     */
    public function getIsFixed()
    {
        return $this->container['is_fixed'];
    }

    /**
     * Sets is_fixed
     *
     * @param bool|null $is_fixed Whether the layer is fixed while the parent is scrolling
     *
     * @return self
     * @deprecated
     */
    public function setIsFixed($is_fixed)
    {
        if (is_null($is_fixed)) {
            throw new \InvalidArgumentException('non-nullable is_fixed cannot be null');
        }
        $this->container['is_fixed'] = $is_fixed;

        return $this;
    }

    /**
     * Gets scroll_behavior
     *
     * @return string
     */
    public function getScrollBehavior()
    {
        return $this->container['scroll_behavior'];
    }

    /**
     * Sets scroll_behavior
     *
     * @param string $scroll_behavior How layer should be treated when the frame is resized
     *
     * @return self
     */
    public function setScrollBehavior($scroll_behavior)
    {
        if (is_null($scroll_behavior)) {
            throw new \InvalidArgumentException('non-nullable scroll_behavior cannot be null');
        }
        $allowedValues = $this->getScrollBehaviorAllowableValues();
        if (!in_array($scroll_behavior, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scroll_behavior', must be one of '%s'",
                    $scroll_behavior,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scroll_behavior'] = $scroll_behavior;

        return $this;
    }

    /**
     * Gets rotation
     *
     * @return float|null
     */
    public function getRotation()
    {
        return $this->container['rotation'];
    }

    /**
     * Sets rotation
     *
     * @param float|null $rotation The rotation of the node, if not 0.
     *
     * @return self
     */
    public function setRotation($rotation)
    {
        if (is_null($rotation)) {
            throw new \InvalidArgumentException('non-nullable rotation cannot be null');
        }
        $this->container['rotation'] = $rotation;

        return $this;
    }

    /**
     * Gets component_property_references
     *
     * @return array<string,string>|null
     */
    public function getComponentPropertyReferences()
    {
        return $this->container['component_property_references'];
    }

    /**
     * Sets component_property_references
     *
     * @param array<string,string>|null $component_property_references A mapping of a layer's property to component property name of component properties attached to this node. The component property name can be used to look up more information on the corresponding component's or component set's componentPropertyDefinitions.
     *
     * @return self
     */
    public function setComponentPropertyReferences($component_property_references)
    {
        if (is_null($component_property_references)) {
            throw new \InvalidArgumentException('non-nullable component_property_references cannot be null');
        }
        $this->container['component_property_references'] = $component_property_references;

        return $this;
    }

    /**
     * Gets plugin_data
     *
     * @return mixed|null
     */
    public function getPluginData()
    {
        return $this->container['plugin_data'];
    }

    /**
     * Sets plugin_data
     *
     * @param mixed|null $plugin_data plugin_data
     *
     * @return self
     */
    public function setPluginData($plugin_data)
    {
        if (is_null($plugin_data)) {
            array_push($this->openAPINullablesSetToNull, 'plugin_data');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('plugin_data', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['plugin_data'] = $plugin_data;

        return $this;
    }

    /**
     * Gets shared_plugin_data
     *
     * @return mixed|null
     */
    public function getSharedPluginData()
    {
        return $this->container['shared_plugin_data'];
    }

    /**
     * Sets shared_plugin_data
     *
     * @param mixed|null $shared_plugin_data shared_plugin_data
     *
     * @return self
     */
    public function setSharedPluginData($shared_plugin_data)
    {
        if (is_null($shared_plugin_data)) {
            array_push($this->openAPINullablesSetToNull, 'shared_plugin_data');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('shared_plugin_data', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['shared_plugin_data'] = $shared_plugin_data;

        return $this;
    }

    /**
     * Gets bound_variables
     *
     * @return \OpenAPI\Client\Model\IsLayerTraitBoundVariables|null
     */
    public function getBoundVariables()
    {
        return $this->container['bound_variables'];
    }

    /**
     * Sets bound_variables
     *
     * @param \OpenAPI\Client\Model\IsLayerTraitBoundVariables|null $bound_variables bound_variables
     *
     * @return self
     */
    public function setBoundVariables($bound_variables)
    {
        if (is_null($bound_variables)) {
            throw new \InvalidArgumentException('non-nullable bound_variables cannot be null');
        }
        $this->container['bound_variables'] = $bound_variables;

        return $this;
    }

    /**
     * Gets explicit_variable_modes
     *
     * @return array<string,string>|null
     */
    public function getExplicitVariableModes()
    {
        return $this->container['explicit_variable_modes'];
    }

    /**
     * Sets explicit_variable_modes
     *
     * @param array<string,string>|null $explicit_variable_modes A mapping of variable collection ID to mode ID representing the explicitly set modes for this node.
     *
     * @return self
     */
    public function setExplicitVariableModes($explicit_variable_modes)
    {
        if (is_null($explicit_variable_modes)) {
            throw new \InvalidArgumentException('non-nullable explicit_variable_modes cannot be null');
        }
        $this->container['explicit_variable_modes'] = $explicit_variable_modes;

        return $this;
    }

    /**
     * Gets blend_mode
     *
     * @return \OpenAPI\Client\Model\BlendMode
     */
    public function getBlendMode()
    {
        return $this->container['blend_mode'];
    }

    /**
     * Sets blend_mode
     *
     * @param \OpenAPI\Client\Model\BlendMode $blend_mode How this node blends with nodes behind it in the scene (see blend mode section for more details)
     *
     * @return self
     */
    public function setBlendMode($blend_mode)
    {
        if (is_null($blend_mode)) {
            throw new \InvalidArgumentException('non-nullable blend_mode cannot be null');
        }
        $this->container['blend_mode'] = $blend_mode;

        return $this;
    }

    /**
     * Gets opacity
     *
     * @return float|null
     */
    public function getOpacity()
    {
        return $this->container['opacity'];
    }

    /**
     * Sets opacity
     *
     * @param float|null $opacity Opacity of the node
     *
     * @return self
     */
    public function setOpacity($opacity)
    {
        if (is_null($opacity)) {
            throw new \InvalidArgumentException('non-nullable opacity cannot be null');
        }

        if (($opacity > 1)) {
            throw new \InvalidArgumentException('invalid value for $opacity when calling SubcanvasNode., must be smaller than or equal to 1.');
        }
        if (($opacity < 0)) {
            throw new \InvalidArgumentException('invalid value for $opacity when calling SubcanvasNode., must be bigger than or equal to 0.');
        }

        $this->container['opacity'] = $opacity;

        return $this;
    }

    /**
     * Gets children
     *
     * @return \OpenAPI\Client\Model\SubcanvasNode[]
     */
    public function getChildren()
    {
        return $this->container['children'];
    }

    /**
     * Sets children
     *
     * @param \OpenAPI\Client\Model\SubcanvasNode[] $children An array of nodes that are direct children of this node
     *
     * @return self
     */
    public function setChildren($children)
    {
        if (is_null($children)) {
            throw new \InvalidArgumentException('non-nullable children cannot be null');
        }
        $this->container['children'] = $children;

        return $this;
    }

    /**
     * Gets absolute_bounding_box
     *
     * @return \OpenAPI\Client\Model\Rectangle
     */
    public function getAbsoluteBoundingBox()
    {
        return $this->container['absolute_bounding_box'];
    }

    /**
     * Sets absolute_bounding_box
     *
     * @param \OpenAPI\Client\Model\Rectangle $absolute_bounding_box absolute_bounding_box
     *
     * @return self
     */
    public function setAbsoluteBoundingBox($absolute_bounding_box)
    {
        if (is_null($absolute_bounding_box)) {
            throw new \InvalidArgumentException('non-nullable absolute_bounding_box cannot be null');
        }
        $this->container['absolute_bounding_box'] = $absolute_bounding_box;

        return $this;
    }

    /**
     * Gets absolute_render_bounds
     *
     * @return \OpenAPI\Client\Model\Rectangle
     */
    public function getAbsoluteRenderBounds()
    {
        return $this->container['absolute_render_bounds'];
    }

    /**
     * Sets absolute_render_bounds
     *
     * @param \OpenAPI\Client\Model\Rectangle $absolute_render_bounds absolute_render_bounds
     *
     * @return self
     */
    public function setAbsoluteRenderBounds($absolute_render_bounds)
    {
        if (is_null($absolute_render_bounds)) {
            throw new \InvalidArgumentException('non-nullable absolute_render_bounds cannot be null');
        }
        $this->container['absolute_render_bounds'] = $absolute_render_bounds;

        return $this;
    }

    /**
     * Gets preserve_ratio
     *
     * @return bool|null
     */
    public function getPreserveRatio()
    {
        return $this->container['preserve_ratio'];
    }

    /**
     * Sets preserve_ratio
     *
     * @param bool|null $preserve_ratio Keep height and width constrained to same ratio.
     *
     * @return self
     */
    public function setPreserveRatio($preserve_ratio)
    {
        if (is_null($preserve_ratio)) {
            throw new \InvalidArgumentException('non-nullable preserve_ratio cannot be null');
        }
        $this->container['preserve_ratio'] = $preserve_ratio;

        return $this;
    }

    /**
     * Gets constraints
     *
     * @return \OpenAPI\Client\Model\LayoutConstraint|null
     */
    public function getConstraints()
    {
        return $this->container['constraints'];
    }

    /**
     * Sets constraints
     *
     * @param \OpenAPI\Client\Model\LayoutConstraint|null $constraints Horizontal and vertical layout constraints for node.
     *
     * @return self
     */
    public function setConstraints($constraints)
    {
        if (is_null($constraints)) {
            throw new \InvalidArgumentException('non-nullable constraints cannot be null');
        }
        $this->container['constraints'] = $constraints;

        return $this;
    }

    /**
     * Gets relative_transform
     *
     * @return float[][]|null
     */
    public function getRelativeTransform()
    {
        return $this->container['relative_transform'];
    }

    /**
     * Sets relative_transform
     *
     * @param float[][]|null $relative_transform A transformation matrix is standard way in computer graphics to represent translation and rotation. These are the top two rows of a 3x3 matrix. The bottom row of the matrix is assumed to be [0, 0, 1]. This is known as an affine transform and is enough to represent translation, rotation, and skew.  The identity transform is [[1, 0, 0], [0, 1, 0]].  A translation matrix will typically look like:  ``` [[1, 0, tx],   [0, 1, ty]] ```  and a rotation matrix will typically look like:  ``` [[cos(angle), sin(angle), 0],   [-sin(angle), cos(angle), 0]] ```  Another way to think about this transform is as three vectors:  - The x axis (t[0][0], t[1][0]) - The y axis (t[0][1], t[1][1]) - The translation offset (t[0][2], t[1][2])  The most common usage of the Transform matrix is the `relativeTransform property`. This particular usage of the matrix has a few additional restrictions. The translation offset can take on any value but we do enforce that the axis vectors are unit vectors (i.e. have length 1). The axes are not required to be at 90° angles to each other.
     *
     * @return self
     */
    public function setRelativeTransform($relative_transform)
    {
        if (is_null($relative_transform)) {
            throw new \InvalidArgumentException('non-nullable relative_transform cannot be null');
        }

        if ((count($relative_transform) > 2)) {
            throw new \InvalidArgumentException('invalid value for $relative_transform when calling SubcanvasNode., number of items must be less than or equal to 2.');
        }
        if ((count($relative_transform) < 2)) {
            throw new \InvalidArgumentException('invalid length for $relative_transform when calling SubcanvasNode., number of items must be greater than or equal to 2.');
        }
        $this->container['relative_transform'] = $relative_transform;

        return $this;
    }

    /**
     * Gets size
     *
     * @return \OpenAPI\Client\Model\Vector|null
     */
    public function getSize()
    {
        return $this->container['size'];
    }

    /**
     * Sets size
     *
     * @param \OpenAPI\Client\Model\Vector|null $size Width and height of element. This is different from the width and height of the bounding box in that the absolute bounding box represents the element after scaling and rotation. Only present if `geometry=paths` is passed.
     *
     * @return self
     */
    public function setSize($size)
    {
        if (is_null($size)) {
            throw new \InvalidArgumentException('non-nullable size cannot be null');
        }
        $this->container['size'] = $size;

        return $this;
    }

    /**
     * Gets layout_align
     *
     * @return string|null
     */
    public function getLayoutAlign()
    {
        return $this->container['layout_align'];
    }

    /**
     * Sets layout_align
     *
     * @param string|null $layout_align Determines if the layer should stretch along the parent's counter axis. This property is only provided for direct children of auto-layout frames.  - `INHERIT` - `STRETCH`  In previous versions of auto layout, determined how the layer is aligned inside an auto-layout frame. This property is only provided for direct children of auto-layout frames.  - `MIN` - `CENTER` - `MAX` - `STRETCH`  In horizontal auto-layout frames, \"MIN\" and \"MAX\" correspond to \"TOP\" and \"BOTTOM\". In vertical auto-layout frames, \"MIN\" and \"MAX\" correspond to \"LEFT\" and \"RIGHT\".
     *
     * @return self
     */
    public function setLayoutAlign($layout_align)
    {
        if (is_null($layout_align)) {
            throw new \InvalidArgumentException('non-nullable layout_align cannot be null');
        }
        $allowedValues = $this->getLayoutAlignAllowableValues();
        if (!in_array($layout_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_align', must be one of '%s'",
                    $layout_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_align'] = $layout_align;

        return $this;
    }

    /**
     * Gets layout_grow
     *
     * @return float|null
     */
    public function getLayoutGrow()
    {
        return $this->container['layout_grow'];
    }

    /**
     * Sets layout_grow
     *
     * @param float|null $layout_grow This property is applicable only for direct children of auto-layout frames, ignored otherwise. Determines whether a layer should stretch along the parent's primary axis. A `0` corresponds to a fixed size and `1` corresponds to stretch.
     *
     * @return self
     */
    public function setLayoutGrow($layout_grow)
    {
        if (is_null($layout_grow)) {
            throw new \InvalidArgumentException('non-nullable layout_grow cannot be null');
        }
        $allowedValues = $this->getLayoutGrowAllowableValues();
        if (!in_array($layout_grow, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_grow', must be one of '%s'",
                    $layout_grow,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_grow'] = $layout_grow;

        return $this;
    }

    /**
     * Gets layout_positioning
     *
     * @return string|null
     */
    public function getLayoutPositioning()
    {
        return $this->container['layout_positioning'];
    }

    /**
     * Sets layout_positioning
     *
     * @param string|null $layout_positioning Determines whether a layer's size and position should be determined by auto-layout settings or manually adjustable.
     *
     * @return self
     */
    public function setLayoutPositioning($layout_positioning)
    {
        if (is_null($layout_positioning)) {
            throw new \InvalidArgumentException('non-nullable layout_positioning cannot be null');
        }
        $allowedValues = $this->getLayoutPositioningAllowableValues();
        if (!in_array($layout_positioning, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_positioning', must be one of '%s'",
                    $layout_positioning,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_positioning'] = $layout_positioning;

        return $this;
    }

    /**
     * Gets min_width
     *
     * @return float|null
     */
    public function getMinWidth()
    {
        return $this->container['min_width'];
    }

    /**
     * Sets min_width
     *
     * @param float|null $min_width The minimum width of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMinWidth($min_width)
    {
        if (is_null($min_width)) {
            throw new \InvalidArgumentException('non-nullable min_width cannot be null');
        }
        $this->container['min_width'] = $min_width;

        return $this;
    }

    /**
     * Gets max_width
     *
     * @return float|null
     */
    public function getMaxWidth()
    {
        return $this->container['max_width'];
    }

    /**
     * Sets max_width
     *
     * @param float|null $max_width The maximum width of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMaxWidth($max_width)
    {
        if (is_null($max_width)) {
            throw new \InvalidArgumentException('non-nullable max_width cannot be null');
        }
        $this->container['max_width'] = $max_width;

        return $this;
    }

    /**
     * Gets min_height
     *
     * @return float|null
     */
    public function getMinHeight()
    {
        return $this->container['min_height'];
    }

    /**
     * Sets min_height
     *
     * @param float|null $min_height The minimum height of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMinHeight($min_height)
    {
        if (is_null($min_height)) {
            throw new \InvalidArgumentException('non-nullable min_height cannot be null');
        }
        $this->container['min_height'] = $min_height;

        return $this;
    }

    /**
     * Gets max_height
     *
     * @return float|null
     */
    public function getMaxHeight()
    {
        return $this->container['max_height'];
    }

    /**
     * Sets max_height
     *
     * @param float|null $max_height The maximum height of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMaxHeight($max_height)
    {
        if (is_null($max_height)) {
            throw new \InvalidArgumentException('non-nullable max_height cannot be null');
        }
        $this->container['max_height'] = $max_height;

        return $this;
    }

    /**
     * Gets layout_sizing_horizontal
     *
     * @return string|null
     */
    public function getLayoutSizingHorizontal()
    {
        return $this->container['layout_sizing_horizontal'];
    }

    /**
     * Sets layout_sizing_horizontal
     *
     * @param string|null $layout_sizing_horizontal The horizontal sizing setting on this auto-layout frame or frame child. - `FIXED` - `HUG`: only valid on auto-layout frames and text nodes - `FILL`: only valid on auto-layout frame children
     *
     * @return self
     */
    public function setLayoutSizingHorizontal($layout_sizing_horizontal)
    {
        if (is_null($layout_sizing_horizontal)) {
            throw new \InvalidArgumentException('non-nullable layout_sizing_horizontal cannot be null');
        }
        $allowedValues = $this->getLayoutSizingHorizontalAllowableValues();
        if (!in_array($layout_sizing_horizontal, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_sizing_horizontal', must be one of '%s'",
                    $layout_sizing_horizontal,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_sizing_horizontal'] = $layout_sizing_horizontal;

        return $this;
    }

    /**
     * Gets layout_sizing_vertical
     *
     * @return string|null
     */
    public function getLayoutSizingVertical()
    {
        return $this->container['layout_sizing_vertical'];
    }

    /**
     * Sets layout_sizing_vertical
     *
     * @param string|null $layout_sizing_vertical The vertical sizing setting on this auto-layout frame or frame child. - `FIXED` - `HUG`: only valid on auto-layout frames and text nodes - `FILL`: only valid on auto-layout frame children
     *
     * @return self
     */
    public function setLayoutSizingVertical($layout_sizing_vertical)
    {
        if (is_null($layout_sizing_vertical)) {
            throw new \InvalidArgumentException('non-nullable layout_sizing_vertical cannot be null');
        }
        $allowedValues = $this->getLayoutSizingVerticalAllowableValues();
        if (!in_array($layout_sizing_vertical, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_sizing_vertical', must be one of '%s'",
                    $layout_sizing_vertical,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_sizing_vertical'] = $layout_sizing_vertical;

        return $this;
    }

    /**
     * Gets grid_row_count
     *
     * @return float|null
     */
    public function getGridRowCount()
    {
        return $this->container['grid_row_count'];
    }

    /**
     * Sets grid_row_count
     *
     * @param float|null $grid_row_count The number of rows in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowCount($grid_row_count)
    {
        if (is_null($grid_row_count)) {
            throw new \InvalidArgumentException('non-nullable grid_row_count cannot be null');
        }
        $this->container['grid_row_count'] = $grid_row_count;

        return $this;
    }

    /**
     * Gets grid_column_count
     *
     * @return float|null
     */
    public function getGridColumnCount()
    {
        return $this->container['grid_column_count'];
    }

    /**
     * Sets grid_column_count
     *
     * @param float|null $grid_column_count The number of columns in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnCount($grid_column_count)
    {
        if (is_null($grid_column_count)) {
            throw new \InvalidArgumentException('non-nullable grid_column_count cannot be null');
        }
        $this->container['grid_column_count'] = $grid_column_count;

        return $this;
    }

    /**
     * Gets grid_row_gap
     *
     * @return float|null
     */
    public function getGridRowGap()
    {
        return $this->container['grid_row_gap'];
    }

    /**
     * Sets grid_row_gap
     *
     * @param float|null $grid_row_gap The distance between rows in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowGap($grid_row_gap)
    {
        if (is_null($grid_row_gap)) {
            throw new \InvalidArgumentException('non-nullable grid_row_gap cannot be null');
        }
        $this->container['grid_row_gap'] = $grid_row_gap;

        return $this;
    }

    /**
     * Gets grid_column_gap
     *
     * @return float|null
     */
    public function getGridColumnGap()
    {
        return $this->container['grid_column_gap'];
    }

    /**
     * Sets grid_column_gap
     *
     * @param float|null $grid_column_gap The distance between columns in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnGap($grid_column_gap)
    {
        if (is_null($grid_column_gap)) {
            throw new \InvalidArgumentException('non-nullable grid_column_gap cannot be null');
        }
        $this->container['grid_column_gap'] = $grid_column_gap;

        return $this;
    }

    /**
     * Gets grid_columns_sizing
     *
     * @return string|null
     */
    public function getGridColumnsSizing()
    {
        return $this->container['grid_columns_sizing'];
    }

    /**
     * Sets grid_columns_sizing
     *
     * @param string|null $grid_columns_sizing The string for the CSS grid-template-columns property. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnsSizing($grid_columns_sizing)
    {
        if (is_null($grid_columns_sizing)) {
            throw new \InvalidArgumentException('non-nullable grid_columns_sizing cannot be null');
        }
        $this->container['grid_columns_sizing'] = $grid_columns_sizing;

        return $this;
    }

    /**
     * Gets grid_rows_sizing
     *
     * @return string|null
     */
    public function getGridRowsSizing()
    {
        return $this->container['grid_rows_sizing'];
    }

    /**
     * Sets grid_rows_sizing
     *
     * @param string|null $grid_rows_sizing The string for the CSS grid-template-rows property. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowsSizing($grid_rows_sizing)
    {
        if (is_null($grid_rows_sizing)) {
            throw new \InvalidArgumentException('non-nullable grid_rows_sizing cannot be null');
        }
        $this->container['grid_rows_sizing'] = $grid_rows_sizing;

        return $this;
    }

    /**
     * Gets grid_child_horizontal_align
     *
     * @return string|null
     */
    public function getGridChildHorizontalAlign()
    {
        return $this->container['grid_child_horizontal_align'];
    }

    /**
     * Sets grid_child_horizontal_align
     *
     * @param string|null $grid_child_horizontal_align Determines how a GRID frame's child should be aligned in the horizontal direction within its grid area. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridChildHorizontalAlign($grid_child_horizontal_align)
    {
        if (is_null($grid_child_horizontal_align)) {
            throw new \InvalidArgumentException('non-nullable grid_child_horizontal_align cannot be null');
        }
        $allowedValues = $this->getGridChildHorizontalAlignAllowableValues();
        if (!in_array($grid_child_horizontal_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'grid_child_horizontal_align', must be one of '%s'",
                    $grid_child_horizontal_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['grid_child_horizontal_align'] = $grid_child_horizontal_align;

        return $this;
    }

    /**
     * Gets grid_child_vertical_align
     *
     * @return string|null
     */
    public function getGridChildVerticalAlign()
    {
        return $this->container['grid_child_vertical_align'];
    }

    /**
     * Sets grid_child_vertical_align
     *
     * @param string|null $grid_child_vertical_align Determines how a GRID frame's child should be aligned in the vertical direction within its grid area. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridChildVerticalAlign($grid_child_vertical_align)
    {
        if (is_null($grid_child_vertical_align)) {
            throw new \InvalidArgumentException('non-nullable grid_child_vertical_align cannot be null');
        }
        $allowedValues = $this->getGridChildVerticalAlignAllowableValues();
        if (!in_array($grid_child_vertical_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'grid_child_vertical_align', must be one of '%s'",
                    $grid_child_vertical_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['grid_child_vertical_align'] = $grid_child_vertical_align;

        return $this;
    }

    /**
     * Gets grid_row_span
     *
     * @return float|null
     */
    public function getGridRowSpan()
    {
        return $this->container['grid_row_span'];
    }

    /**
     * Sets grid_row_span
     *
     * @param float|null $grid_row_span The number of rows that a GRID frame's child should span. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowSpan($grid_row_span)
    {
        if (is_null($grid_row_span)) {
            throw new \InvalidArgumentException('non-nullable grid_row_span cannot be null');
        }
        $this->container['grid_row_span'] = $grid_row_span;

        return $this;
    }

    /**
     * Gets grid_column_span
     *
     * @return float|null
     */
    public function getGridColumnSpan()
    {
        return $this->container['grid_column_span'];
    }

    /**
     * Sets grid_column_span
     *
     * @param float|null $grid_column_span The number of columns that a GRID frame's child should span. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnSpan($grid_column_span)
    {
        if (is_null($grid_column_span)) {
            throw new \InvalidArgumentException('non-nullable grid_column_span cannot be null');
        }
        $this->container['grid_column_span'] = $grid_column_span;

        return $this;
    }

    /**
     * Gets grid_row_anchor_index
     *
     * @return float|null
     */
    public function getGridRowAnchorIndex()
    {
        return $this->container['grid_row_anchor_index'];
    }

    /**
     * Sets grid_row_anchor_index
     *
     * @param float|null $grid_row_anchor_index The index of the row that a GRID frame's child should be anchored to. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowAnchorIndex($grid_row_anchor_index)
    {
        if (is_null($grid_row_anchor_index)) {
            throw new \InvalidArgumentException('non-nullable grid_row_anchor_index cannot be null');
        }
        $this->container['grid_row_anchor_index'] = $grid_row_anchor_index;

        return $this;
    }

    /**
     * Gets grid_column_anchor_index
     *
     * @return float|null
     */
    public function getGridColumnAnchorIndex()
    {
        return $this->container['grid_column_anchor_index'];
    }

    /**
     * Sets grid_column_anchor_index
     *
     * @param float|null $grid_column_anchor_index The index of the column that a GRID frame's child should be anchored to. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnAnchorIndex($grid_column_anchor_index)
    {
        if (is_null($grid_column_anchor_index)) {
            throw new \InvalidArgumentException('non-nullable grid_column_anchor_index cannot be null');
        }
        $this->container['grid_column_anchor_index'] = $grid_column_anchor_index;

        return $this;
    }

    /**
     * Gets fills
     *
     * @return \OpenAPI\Client\Model\Paint[]
     */
    public function getFills()
    {
        return $this->container['fills'];
    }

    /**
     * Sets fills
     *
     * @param \OpenAPI\Client\Model\Paint[] $fills An array of fill paints applied to the node.
     *
     * @return self
     */
    public function setFills($fills)
    {
        if (is_null($fills)) {
            throw new \InvalidArgumentException('non-nullable fills cannot be null');
        }
        $this->container['fills'] = $fills;

        return $this;
    }

    /**
     * Gets styles
     *
     * @return array<string,string>|null
     */
    public function getStyles()
    {
        return $this->container['styles'];
    }

    /**
     * Sets styles
     *
     * @param array<string,string>|null $styles A mapping of a StyleType to style ID (see Style) of styles present on this node. The style ID can be used to look up more information about the style in the top-level styles field.
     *
     * @return self
     */
    public function setStyles($styles)
    {
        if (is_null($styles)) {
            throw new \InvalidArgumentException('non-nullable styles cannot be null');
        }
        $this->container['styles'] = $styles;

        return $this;
    }

    /**
     * Gets strokes
     *
     * @return \OpenAPI\Client\Model\Paint[]|null
     */
    public function getStrokes()
    {
        return $this->container['strokes'];
    }

    /**
     * Sets strokes
     *
     * @param \OpenAPI\Client\Model\Paint[]|null $strokes An array of stroke paints applied to the node.
     *
     * @return self
     */
    public function setStrokes($strokes)
    {
        if (is_null($strokes)) {
            throw new \InvalidArgumentException('non-nullable strokes cannot be null');
        }
        $this->container['strokes'] = $strokes;

        return $this;
    }

    /**
     * Gets stroke_weight
     *
     * @return float|null
     */
    public function getStrokeWeight()
    {
        return $this->container['stroke_weight'];
    }

    /**
     * Sets stroke_weight
     *
     * @param float|null $stroke_weight The weight of strokes on the node.
     *
     * @return self
     */
    public function setStrokeWeight($stroke_weight)
    {
        if (is_null($stroke_weight)) {
            throw new \InvalidArgumentException('non-nullable stroke_weight cannot be null');
        }
        $this->container['stroke_weight'] = $stroke_weight;

        return $this;
    }

    /**
     * Gets stroke_align
     *
     * @return string|null
     */
    public function getStrokeAlign()
    {
        return $this->container['stroke_align'];
    }

    /**
     * Sets stroke_align
     *
     * @param string|null $stroke_align Position of stroke relative to vector outline, as a string enum  - `INSIDE`: stroke drawn inside the shape boundary - `OUTSIDE`: stroke drawn outside the shape boundary - `CENTER`: stroke drawn centered along the shape boundary
     *
     * @return self
     */
    public function setStrokeAlign($stroke_align)
    {
        if (is_null($stroke_align)) {
            throw new \InvalidArgumentException('non-nullable stroke_align cannot be null');
        }
        $allowedValues = $this->getStrokeAlignAllowableValues();
        if (!in_array($stroke_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'stroke_align', must be one of '%s'",
                    $stroke_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['stroke_align'] = $stroke_align;

        return $this;
    }

    /**
     * Gets stroke_join
     *
     * @return string|null
     */
    public function getStrokeJoin()
    {
        return $this->container['stroke_join'];
    }

    /**
     * Sets stroke_join
     *
     * @param string|null $stroke_join A string enum with value of \"MITER\", \"BEVEL\", or \"ROUND\", describing how corners in vector paths are rendered.
     *
     * @return self
     */
    public function setStrokeJoin($stroke_join)
    {
        if (is_null($stroke_join)) {
            throw new \InvalidArgumentException('non-nullable stroke_join cannot be null');
        }
        $allowedValues = $this->getStrokeJoinAllowableValues();
        if (!in_array($stroke_join, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'stroke_join', must be one of '%s'",
                    $stroke_join,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['stroke_join'] = $stroke_join;

        return $this;
    }

    /**
     * Gets stroke_dashes
     *
     * @return float[]|null
     */
    public function getStrokeDashes()
    {
        return $this->container['stroke_dashes'];
    }

    /**
     * Sets stroke_dashes
     *
     * @param float[]|null $stroke_dashes An array of floating point numbers describing the pattern of dash length and gap lengths that the vector stroke will use when drawn.  For example a value of [1, 2] indicates that the stroke will be drawn with a dash of length 1 followed by a gap of length 2, repeated.
     *
     * @return self
     */
    public function setStrokeDashes($stroke_dashes)
    {
        if (is_null($stroke_dashes)) {
            throw new \InvalidArgumentException('non-nullable stroke_dashes cannot be null');
        }
        $this->container['stroke_dashes'] = $stroke_dashes;

        return $this;
    }

    /**
     * Gets fill_override_table
     *
     * @return array<string,\OpenAPI\Client\Model\HasGeometryTraitAllOfFillOverrideTable>|null
     */
    public function getFillOverrideTable()
    {
        return $this->container['fill_override_table'];
    }

    /**
     * Sets fill_override_table
     *
     * @param array<string,\OpenAPI\Client\Model\HasGeometryTraitAllOfFillOverrideTable>|null $fill_override_table Map from ID to PaintOverride for looking up fill overrides. To see which regions are overriden, you must use the `geometry=paths` option. Each path returned may have an `overrideID` which maps to this table.
     *
     * @return self
     */
    public function setFillOverrideTable($fill_override_table)
    {
        if (is_null($fill_override_table)) {
            throw new \InvalidArgumentException('non-nullable fill_override_table cannot be null');
        }
        $this->container['fill_override_table'] = $fill_override_table;

        return $this;
    }

    /**
     * Gets fill_geometry
     *
     * @return \OpenAPI\Client\Model\Path[]|null
     */
    public function getFillGeometry()
    {
        return $this->container['fill_geometry'];
    }

    /**
     * Sets fill_geometry
     *
     * @param \OpenAPI\Client\Model\Path[]|null $fill_geometry Only specified if parameter `geometry=paths` is used. An array of paths representing the object fill.
     *
     * @return self
     */
    public function setFillGeometry($fill_geometry)
    {
        if (is_null($fill_geometry)) {
            throw new \InvalidArgumentException('non-nullable fill_geometry cannot be null');
        }
        $this->container['fill_geometry'] = $fill_geometry;

        return $this;
    }

    /**
     * Gets stroke_geometry
     *
     * @return \OpenAPI\Client\Model\Path[]|null
     */
    public function getStrokeGeometry()
    {
        return $this->container['stroke_geometry'];
    }

    /**
     * Sets stroke_geometry
     *
     * @param \OpenAPI\Client\Model\Path[]|null $stroke_geometry Only specified if parameter `geometry=paths` is used. An array of paths representing the object stroke.
     *
     * @return self
     */
    public function setStrokeGeometry($stroke_geometry)
    {
        if (is_null($stroke_geometry)) {
            throw new \InvalidArgumentException('non-nullable stroke_geometry cannot be null');
        }
        $this->container['stroke_geometry'] = $stroke_geometry;

        return $this;
    }

    /**
     * Gets stroke_cap
     *
     * @return string|null
     */
    public function getStrokeCap()
    {
        return $this->container['stroke_cap'];
    }

    /**
     * Sets stroke_cap
     *
     * @param string|null $stroke_cap A string enum describing the end caps of vector paths.
     *
     * @return self
     */
    public function setStrokeCap($stroke_cap)
    {
        if (is_null($stroke_cap)) {
            throw new \InvalidArgumentException('non-nullable stroke_cap cannot be null');
        }
        $allowedValues = $this->getStrokeCapAllowableValues();
        if (!in_array($stroke_cap, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'stroke_cap', must be one of '%s'",
                    $stroke_cap,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['stroke_cap'] = $stroke_cap;

        return $this;
    }

    /**
     * Gets stroke_miter_angle
     *
     * @return float|null
     */
    public function getStrokeMiterAngle()
    {
        return $this->container['stroke_miter_angle'];
    }

    /**
     * Sets stroke_miter_angle
     *
     * @param float|null $stroke_miter_angle Only valid if `strokeJoin` is \"MITER\". The corner angle, in degrees, below which `strokeJoin` will be set to \"BEVEL\" to avoid super sharp corners. By default this is 28.96 degrees.
     *
     * @return self
     */
    public function setStrokeMiterAngle($stroke_miter_angle)
    {
        if (is_null($stroke_miter_angle)) {
            throw new \InvalidArgumentException('non-nullable stroke_miter_angle cannot be null');
        }
        $this->container['stroke_miter_angle'] = $stroke_miter_angle;

        return $this;
    }

    /**
     * Gets export_settings
     *
     * @return \OpenAPI\Client\Model\ExportSetting[]|null
     */
    public function getExportSettings()
    {
        return $this->container['export_settings'];
    }

    /**
     * Sets export_settings
     *
     * @param \OpenAPI\Client\Model\ExportSetting[]|null $export_settings An array of export settings representing images to export from the node.
     *
     * @return self
     */
    public function setExportSettings($export_settings)
    {
        if (is_null($export_settings)) {
            throw new \InvalidArgumentException('non-nullable export_settings cannot be null');
        }
        $this->container['export_settings'] = $export_settings;

        return $this;
    }

    /**
     * Gets effects
     *
     * @return \OpenAPI\Client\Model\Effect[]
     */
    public function getEffects()
    {
        return $this->container['effects'];
    }

    /**
     * Sets effects
     *
     * @param \OpenAPI\Client\Model\Effect[] $effects An array of effects attached to this node (see effects section for more details)
     *
     * @return self
     */
    public function setEffects($effects)
    {
        if (is_null($effects)) {
            throw new \InvalidArgumentException('non-nullable effects cannot be null');
        }
        $this->container['effects'] = $effects;

        return $this;
    }

    /**
     * Gets is_mask
     *
     * @return bool|null
     */
    public function getIsMask()
    {
        return $this->container['is_mask'];
    }

    /**
     * Sets is_mask
     *
     * @param bool|null $is_mask Does this node mask sibling nodes in front of it?
     *
     * @return self
     */
    public function setIsMask($is_mask)
    {
        if (is_null($is_mask)) {
            throw new \InvalidArgumentException('non-nullable is_mask cannot be null');
        }
        $this->container['is_mask'] = $is_mask;

        return $this;
    }

    /**
     * Gets mask_type
     *
     * @return string|null
     */
    public function getMaskType()
    {
        return $this->container['mask_type'];
    }

    /**
     * Sets mask_type
     *
     * @param string|null $mask_type If this layer is a mask, this property describes the operation used to mask the layer's siblings. The value may be one of the following:  - ALPHA: the mask node's alpha channel will be used to determine the opacity of each pixel in the masked result. - VECTOR: if the mask node has visible fill paints, every pixel inside the node's fill regions will be fully visible in the masked result. If the mask has visible stroke paints, every pixel inside the node's stroke regions will be fully visible in the masked result. - LUMINANCE: the luminance value of each pixel of the mask node will be used to determine the opacity of that pixel in the masked result.
     *
     * @return self
     */
    public function setMaskType($mask_type)
    {
        if (is_null($mask_type)) {
            throw new \InvalidArgumentException('non-nullable mask_type cannot be null');
        }
        $allowedValues = $this->getMaskTypeAllowableValues();
        if (!in_array($mask_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'mask_type', must be one of '%s'",
                    $mask_type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mask_type'] = $mask_type;

        return $this;
    }

    /**
     * Gets is_mask_outline
     *
     * @return bool|null
     * @deprecated
     */
    public function getIsMaskOutline()
    {
        return $this->container['is_mask_outline'];
    }

    /**
     * Sets is_mask_outline
     *
     * @param bool|null $is_mask_outline True if maskType is VECTOR. This field is deprecated; use maskType instead.
     *
     * @return self
     * @deprecated
     */
    public function setIsMaskOutline($is_mask_outline)
    {
        if (is_null($is_mask_outline)) {
            throw new \InvalidArgumentException('non-nullable is_mask_outline cannot be null');
        }
        $this->container['is_mask_outline'] = $is_mask_outline;

        return $this;
    }

    /**
     * Gets transition_node_id
     *
     * @return string|null
     */
    public function getTransitionNodeId()
    {
        return $this->container['transition_node_id'];
    }

    /**
     * Sets transition_node_id
     *
     * @param string|null $transition_node_id Node ID of node to transition to in prototyping
     *
     * @return self
     */
    public function setTransitionNodeId($transition_node_id)
    {
        if (is_null($transition_node_id)) {
            throw new \InvalidArgumentException('non-nullable transition_node_id cannot be null');
        }
        $this->container['transition_node_id'] = $transition_node_id;

        return $this;
    }

    /**
     * Gets transition_duration
     *
     * @return float|null
     */
    public function getTransitionDuration()
    {
        return $this->container['transition_duration'];
    }

    /**
     * Sets transition_duration
     *
     * @param float|null $transition_duration The duration of the prototyping transition on this node (in milliseconds). This will override the default transition duration on the prototype, for this node.
     *
     * @return self
     */
    public function setTransitionDuration($transition_duration)
    {
        if (is_null($transition_duration)) {
            throw new \InvalidArgumentException('non-nullable transition_duration cannot be null');
        }
        $this->container['transition_duration'] = $transition_duration;

        return $this;
    }

    /**
     * Gets transition_easing
     *
     * @return \OpenAPI\Client\Model\EasingType|null
     */
    public function getTransitionEasing()
    {
        return $this->container['transition_easing'];
    }

    /**
     * Sets transition_easing
     *
     * @param \OpenAPI\Client\Model\EasingType|null $transition_easing The easing curve used in the prototyping transition on this node.
     *
     * @return self
     */
    public function setTransitionEasing($transition_easing)
    {
        if (is_null($transition_easing)) {
            throw new \InvalidArgumentException('non-nullable transition_easing cannot be null');
        }
        $this->container['transition_easing'] = $transition_easing;

        return $this;
    }

    /**
     * Gets interactions
     *
     * @return \OpenAPI\Client\Model\Interaction[]|null
     */
    public function getInteractions()
    {
        return $this->container['interactions'];
    }

    /**
     * Sets interactions
     *
     * @param \OpenAPI\Client\Model\Interaction[]|null $interactions interactions
     *
     * @return self
     */
    public function setInteractions($interactions)
    {
        if (is_null($interactions)) {
            throw new \InvalidArgumentException('non-nullable interactions cannot be null');
        }
        $this->container['interactions'] = $interactions;

        return $this;
    }

    /**
     * Gets clips_content
     *
     * @return bool
     */
    public function getClipsContent()
    {
        return $this->container['clips_content'];
    }

    /**
     * Sets clips_content
     *
     * @param bool $clips_content Whether or not this node clip content outside of its bounds
     *
     * @return self
     */
    public function setClipsContent($clips_content)
    {
        if (is_null($clips_content)) {
            throw new \InvalidArgumentException('non-nullable clips_content cannot be null');
        }
        $this->container['clips_content'] = $clips_content;

        return $this;
    }

    /**
     * Gets background
     *
     * @return \OpenAPI\Client\Model\Paint[]|null
     */
    public function getBackground()
    {
        return $this->container['background'];
    }

    /**
     * Sets background
     *
     * @param \OpenAPI\Client\Model\Paint[]|null $background Background of the node. This is deprecated, as backgrounds for frames are now in the `fills` field.
     *
     * @return self
     */
    public function setBackground($background)
    {
        if (is_null($background)) {
            throw new \InvalidArgumentException('non-nullable background cannot be null');
        }
        $this->container['background'] = $background;

        return $this;
    }

    /**
     * Gets background_color
     *
     * @return \OpenAPI\Client\Model\RGBA|null
     * @deprecated
     */
    public function getBackgroundColor()
    {
        return $this->container['background_color'];
    }

    /**
     * Sets background_color
     *
     * @param \OpenAPI\Client\Model\RGBA|null $background_color Background color of the node. This is deprecated, as frames now support more than a solid color as a background. Please use the `fills` field instead.
     *
     * @return self
     * @deprecated
     */
    public function setBackgroundColor($background_color)
    {
        if (is_null($background_color)) {
            throw new \InvalidArgumentException('non-nullable background_color cannot be null');
        }
        $this->container['background_color'] = $background_color;

        return $this;
    }

    /**
     * Gets layout_grids
     *
     * @return \OpenAPI\Client\Model\LayoutGrid[]|null
     */
    public function getLayoutGrids()
    {
        return $this->container['layout_grids'];
    }

    /**
     * Sets layout_grids
     *
     * @param \OpenAPI\Client\Model\LayoutGrid[]|null $layout_grids An array of layout grids attached to this node (see layout grids section for more details). GROUP nodes do not have this attribute
     *
     * @return self
     */
    public function setLayoutGrids($layout_grids)
    {
        if (is_null($layout_grids)) {
            throw new \InvalidArgumentException('non-nullable layout_grids cannot be null');
        }
        $this->container['layout_grids'] = $layout_grids;

        return $this;
    }

    /**
     * Gets overflow_direction
     *
     * @return string|null
     */
    public function getOverflowDirection()
    {
        return $this->container['overflow_direction'];
    }

    /**
     * Sets overflow_direction
     *
     * @param string|null $overflow_direction Whether a node has primary axis scrolling, horizontal or vertical.
     *
     * @return self
     */
    public function setOverflowDirection($overflow_direction)
    {
        if (is_null($overflow_direction)) {
            throw new \InvalidArgumentException('non-nullable overflow_direction cannot be null');
        }
        $allowedValues = $this->getOverflowDirectionAllowableValues();
        if (!in_array($overflow_direction, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'overflow_direction', must be one of '%s'",
                    $overflow_direction,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['overflow_direction'] = $overflow_direction;

        return $this;
    }

    /**
     * Gets layout_mode
     *
     * @return string|null
     */
    public function getLayoutMode()
    {
        return $this->container['layout_mode'];
    }

    /**
     * Sets layout_mode
     *
     * @param string|null $layout_mode Whether this layer uses auto-layout to position its children.
     *
     * @return self
     */
    public function setLayoutMode($layout_mode)
    {
        if (is_null($layout_mode)) {
            throw new \InvalidArgumentException('non-nullable layout_mode cannot be null');
        }
        $allowedValues = $this->getLayoutModeAllowableValues();
        if (!in_array($layout_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_mode', must be one of '%s'",
                    $layout_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_mode'] = $layout_mode;

        return $this;
    }

    /**
     * Gets primary_axis_sizing_mode
     *
     * @return string|null
     */
    public function getPrimaryAxisSizingMode()
    {
        return $this->container['primary_axis_sizing_mode'];
    }

    /**
     * Sets primary_axis_sizing_mode
     *
     * @param string|null $primary_axis_sizing_mode Whether the primary axis has a fixed length (determined by the user) or an automatic length (determined by the layout engine). This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setPrimaryAxisSizingMode($primary_axis_sizing_mode)
    {
        if (is_null($primary_axis_sizing_mode)) {
            throw new \InvalidArgumentException('non-nullable primary_axis_sizing_mode cannot be null');
        }
        $allowedValues = $this->getPrimaryAxisSizingModeAllowableValues();
        if (!in_array($primary_axis_sizing_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'primary_axis_sizing_mode', must be one of '%s'",
                    $primary_axis_sizing_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['primary_axis_sizing_mode'] = $primary_axis_sizing_mode;

        return $this;
    }

    /**
     * Gets counter_axis_sizing_mode
     *
     * @return string|null
     */
    public function getCounterAxisSizingMode()
    {
        return $this->container['counter_axis_sizing_mode'];
    }

    /**
     * Sets counter_axis_sizing_mode
     *
     * @param string|null $counter_axis_sizing_mode Whether the counter axis has a fixed length (determined by the user) or an automatic length (determined by the layout engine). This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setCounterAxisSizingMode($counter_axis_sizing_mode)
    {
        if (is_null($counter_axis_sizing_mode)) {
            throw new \InvalidArgumentException('non-nullable counter_axis_sizing_mode cannot be null');
        }
        $allowedValues = $this->getCounterAxisSizingModeAllowableValues();
        if (!in_array($counter_axis_sizing_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'counter_axis_sizing_mode', must be one of '%s'",
                    $counter_axis_sizing_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['counter_axis_sizing_mode'] = $counter_axis_sizing_mode;

        return $this;
    }

    /**
     * Gets primary_axis_align_items
     *
     * @return string|null
     */
    public function getPrimaryAxisAlignItems()
    {
        return $this->container['primary_axis_align_items'];
    }

    /**
     * Sets primary_axis_align_items
     *
     * @param string|null $primary_axis_align_items Determines how the auto-layout frame's children should be aligned in the primary axis direction. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setPrimaryAxisAlignItems($primary_axis_align_items)
    {
        if (is_null($primary_axis_align_items)) {
            throw new \InvalidArgumentException('non-nullable primary_axis_align_items cannot be null');
        }
        $allowedValues = $this->getPrimaryAxisAlignItemsAllowableValues();
        if (!in_array($primary_axis_align_items, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'primary_axis_align_items', must be one of '%s'",
                    $primary_axis_align_items,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['primary_axis_align_items'] = $primary_axis_align_items;

        return $this;
    }

    /**
     * Gets counter_axis_align_items
     *
     * @return string|null
     */
    public function getCounterAxisAlignItems()
    {
        return $this->container['counter_axis_align_items'];
    }

    /**
     * Sets counter_axis_align_items
     *
     * @param string|null $counter_axis_align_items Determines how the auto-layout frame's children should be aligned in the counter axis direction. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setCounterAxisAlignItems($counter_axis_align_items)
    {
        if (is_null($counter_axis_align_items)) {
            throw new \InvalidArgumentException('non-nullable counter_axis_align_items cannot be null');
        }
        $allowedValues = $this->getCounterAxisAlignItemsAllowableValues();
        if (!in_array($counter_axis_align_items, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'counter_axis_align_items', must be one of '%s'",
                    $counter_axis_align_items,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['counter_axis_align_items'] = $counter_axis_align_items;

        return $this;
    }

    /**
     * Gets padding_left
     *
     * @return float|null
     */
    public function getPaddingLeft()
    {
        return $this->container['padding_left'];
    }

    /**
     * Sets padding_left
     *
     * @param float|null $padding_left The padding between the left border of the frame and its children. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setPaddingLeft($padding_left)
    {
        if (is_null($padding_left)) {
            throw new \InvalidArgumentException('non-nullable padding_left cannot be null');
        }
        $this->container['padding_left'] = $padding_left;

        return $this;
    }

    /**
     * Gets padding_right
     *
     * @return float|null
     */
    public function getPaddingRight()
    {
        return $this->container['padding_right'];
    }

    /**
     * Sets padding_right
     *
     * @param float|null $padding_right The padding between the right border of the frame and its children. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setPaddingRight($padding_right)
    {
        if (is_null($padding_right)) {
            throw new \InvalidArgumentException('non-nullable padding_right cannot be null');
        }
        $this->container['padding_right'] = $padding_right;

        return $this;
    }

    /**
     * Gets padding_top
     *
     * @return float|null
     */
    public function getPaddingTop()
    {
        return $this->container['padding_top'];
    }

    /**
     * Sets padding_top
     *
     * @param float|null $padding_top The padding between the top border of the frame and its children. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setPaddingTop($padding_top)
    {
        if (is_null($padding_top)) {
            throw new \InvalidArgumentException('non-nullable padding_top cannot be null');
        }
        $this->container['padding_top'] = $padding_top;

        return $this;
    }

    /**
     * Gets padding_bottom
     *
     * @return float|null
     */
    public function getPaddingBottom()
    {
        return $this->container['padding_bottom'];
    }

    /**
     * Sets padding_bottom
     *
     * @param float|null $padding_bottom The padding between the bottom border of the frame and its children. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setPaddingBottom($padding_bottom)
    {
        if (is_null($padding_bottom)) {
            throw new \InvalidArgumentException('non-nullable padding_bottom cannot be null');
        }
        $this->container['padding_bottom'] = $padding_bottom;

        return $this;
    }

    /**
     * Gets item_spacing
     *
     * @return float|null
     */
    public function getItemSpacing()
    {
        return $this->container['item_spacing'];
    }

    /**
     * Sets item_spacing
     *
     * @param float|null $item_spacing The distance between children of the frame. Can be negative. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setItemSpacing($item_spacing)
    {
        if (is_null($item_spacing)) {
            throw new \InvalidArgumentException('non-nullable item_spacing cannot be null');
        }
        $this->container['item_spacing'] = $item_spacing;

        return $this;
    }

    /**
     * Gets item_reverse_z_index
     *
     * @return bool|null
     */
    public function getItemReverseZIndex()
    {
        return $this->container['item_reverse_z_index'];
    }

    /**
     * Sets item_reverse_z_index
     *
     * @param bool|null $item_reverse_z_index Determines the canvas stacking order of layers in this frame. When true, the first layer will be draw on top. This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setItemReverseZIndex($item_reverse_z_index)
    {
        if (is_null($item_reverse_z_index)) {
            throw new \InvalidArgumentException('non-nullable item_reverse_z_index cannot be null');
        }
        $this->container['item_reverse_z_index'] = $item_reverse_z_index;

        return $this;
    }

    /**
     * Gets strokes_included_in_layout
     *
     * @return bool|null
     */
    public function getStrokesIncludedInLayout()
    {
        return $this->container['strokes_included_in_layout'];
    }

    /**
     * Sets strokes_included_in_layout
     *
     * @param bool|null $strokes_included_in_layout Determines whether strokes are included in layout calculations. When true, auto-layout frames behave like css \"box-sizing: border-box\". This property is only applicable for auto-layout frames.
     *
     * @return self
     */
    public function setStrokesIncludedInLayout($strokes_included_in_layout)
    {
        if (is_null($strokes_included_in_layout)) {
            throw new \InvalidArgumentException('non-nullable strokes_included_in_layout cannot be null');
        }
        $this->container['strokes_included_in_layout'] = $strokes_included_in_layout;

        return $this;
    }

    /**
     * Gets layout_wrap
     *
     * @return string|null
     */
    public function getLayoutWrap()
    {
        return $this->container['layout_wrap'];
    }

    /**
     * Sets layout_wrap
     *
     * @param string|null $layout_wrap Whether this auto-layout frame has wrapping enabled.
     *
     * @return self
     */
    public function setLayoutWrap($layout_wrap)
    {
        if (is_null($layout_wrap)) {
            throw new \InvalidArgumentException('non-nullable layout_wrap cannot be null');
        }
        $allowedValues = $this->getLayoutWrapAllowableValues();
        if (!in_array($layout_wrap, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_wrap', must be one of '%s'",
                    $layout_wrap,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_wrap'] = $layout_wrap;

        return $this;
    }

    /**
     * Gets counter_axis_spacing
     *
     * @return float|null
     */
    public function getCounterAxisSpacing()
    {
        return $this->container['counter_axis_spacing'];
    }

    /**
     * Sets counter_axis_spacing
     *
     * @param float|null $counter_axis_spacing The distance between wrapped tracks of an auto-layout frame. This property is only applicable for auto-layout frames with `layoutWrap: \"WRAP\"`
     *
     * @return self
     */
    public function setCounterAxisSpacing($counter_axis_spacing)
    {
        if (is_null($counter_axis_spacing)) {
            throw new \InvalidArgumentException('non-nullable counter_axis_spacing cannot be null');
        }
        $this->container['counter_axis_spacing'] = $counter_axis_spacing;

        return $this;
    }

    /**
     * Gets counter_axis_align_content
     *
     * @return string|null
     */
    public function getCounterAxisAlignContent()
    {
        return $this->container['counter_axis_align_content'];
    }

    /**
     * Sets counter_axis_align_content
     *
     * @param string|null $counter_axis_align_content Determines how the auto-layout frame’s wrapped tracks should be aligned in the counter axis direction. This property is only applicable for auto-layout frames with `layoutWrap: \"WRAP\"`.
     *
     * @return self
     */
    public function setCounterAxisAlignContent($counter_axis_align_content)
    {
        if (is_null($counter_axis_align_content)) {
            throw new \InvalidArgumentException('non-nullable counter_axis_align_content cannot be null');
        }
        $allowedValues = $this->getCounterAxisAlignContentAllowableValues();
        if (!in_array($counter_axis_align_content, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'counter_axis_align_content', must be one of '%s'",
                    $counter_axis_align_content,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['counter_axis_align_content'] = $counter_axis_align_content;

        return $this;
    }

    /**
     * Gets corner_radius
     *
     * @return float|null
     */
    public function getCornerRadius()
    {
        return $this->container['corner_radius'];
    }

    /**
     * Sets corner_radius
     *
     * @param float|null $corner_radius Radius of each corner if a single radius is set for all corners
     *
     * @return self
     */
    public function setCornerRadius($corner_radius)
    {
        if (is_null($corner_radius)) {
            throw new \InvalidArgumentException('non-nullable corner_radius cannot be null');
        }
        $this->container['corner_radius'] = $corner_radius;

        return $this;
    }

    /**
     * Gets corner_smoothing
     *
     * @return float|null
     */
    public function getCornerSmoothing()
    {
        return $this->container['corner_smoothing'];
    }

    /**
     * Sets corner_smoothing
     *
     * @param float|null $corner_smoothing A value that lets you control how \"smooth\" the corners are. Ranges from 0 to 1. 0 is the default and means that the corner is perfectly circular. A value of 0.6 means the corner matches the iOS 7 \"squircle\" icon shape. Other values produce various other curves.
     *
     * @return self
     */
    public function setCornerSmoothing($corner_smoothing)
    {
        if (is_null($corner_smoothing)) {
            throw new \InvalidArgumentException('non-nullable corner_smoothing cannot be null');
        }
        $this->container['corner_smoothing'] = $corner_smoothing;

        return $this;
    }

    /**
     * Gets rectangle_corner_radii
     *
     * @return float[]|null
     */
    public function getRectangleCornerRadii()
    {
        return $this->container['rectangle_corner_radii'];
    }

    /**
     * Sets rectangle_corner_radii
     *
     * @param float[]|null $rectangle_corner_radii Array of length 4 of the radius of each corner of the frame, starting in the top left and proceeding clockwise.  Values are given in the order top-left, top-right, bottom-right, bottom-left.
     *
     * @return self
     */
    public function setRectangleCornerRadii($rectangle_corner_radii)
    {
        if (is_null($rectangle_corner_radii)) {
            throw new \InvalidArgumentException('non-nullable rectangle_corner_radii cannot be null');
        }

        if ((count($rectangle_corner_radii) > 4)) {
            throw new \InvalidArgumentException('invalid value for $rectangle_corner_radii when calling SubcanvasNode., number of items must be less than or equal to 4.');
        }
        if ((count($rectangle_corner_radii) < 4)) {
            throw new \InvalidArgumentException('invalid length for $rectangle_corner_radii when calling SubcanvasNode., number of items must be greater than or equal to 4.');
        }
        $this->container['rectangle_corner_radii'] = $rectangle_corner_radii;

        return $this;
    }

    /**
     * Gets individual_stroke_weights
     *
     * @return \OpenAPI\Client\Model\StrokeWeights|null
     */
    public function getIndividualStrokeWeights()
    {
        return $this->container['individual_stroke_weights'];
    }

    /**
     * Sets individual_stroke_weights
     *
     * @param \OpenAPI\Client\Model\StrokeWeights|null $individual_stroke_weights An object including the top, bottom, left, and right stroke weights. Only returned if individual stroke weights are used.
     *
     * @return self
     */
    public function setIndividualStrokeWeights($individual_stroke_weights)
    {
        if (is_null($individual_stroke_weights)) {
            throw new \InvalidArgumentException('non-nullable individual_stroke_weights cannot be null');
        }
        $this->container['individual_stroke_weights'] = $individual_stroke_weights;

        return $this;
    }

    /**
     * Gets dev_status
     *
     * @return \OpenAPI\Client\Model\DevStatusTraitDevStatus|null
     */
    public function getDevStatus()
    {
        return $this->container['dev_status'];
    }

    /**
     * Sets dev_status
     *
     * @param \OpenAPI\Client\Model\DevStatusTraitDevStatus|null $dev_status dev_status
     *
     * @return self
     */
    public function setDevStatus($dev_status)
    {
        if (is_null($dev_status)) {
            throw new \InvalidArgumentException('non-nullable dev_status cannot be null');
        }
        $this->container['dev_status'] = $dev_status;

        return $this;
    }

    /**
     * Gets component_property_definitions
     *
     * @return array<string,\OpenAPI\Client\Model\ComponentPropertyDefinition>|null
     */
    public function getComponentPropertyDefinitions()
    {
        return $this->container['component_property_definitions'];
    }

    /**
     * Sets component_property_definitions
     *
     * @param array<string,\OpenAPI\Client\Model\ComponentPropertyDefinition>|null $component_property_definitions A mapping of name to `ComponentPropertyDefinition` for every component property on this component. Each property has a type, defaultValue, and other optional values.
     *
     * @return self
     */
    public function setComponentPropertyDefinitions($component_property_definitions)
    {
        if (is_null($component_property_definitions)) {
            throw new \InvalidArgumentException('non-nullable component_property_definitions cannot be null');
        }
        $this->container['component_property_definitions'] = $component_property_definitions;

        return $this;
    }

    /**
     * Gets connector_start
     *
     * @return \OpenAPI\Client\Model\ConnectorEndpoint
     */
    public function getConnectorStart()
    {
        return $this->container['connector_start'];
    }

    /**
     * Sets connector_start
     *
     * @param \OpenAPI\Client\Model\ConnectorEndpoint $connector_start The starting point of the connector.
     *
     * @return self
     */
    public function setConnectorStart($connector_start)
    {
        if (is_null($connector_start)) {
            throw new \InvalidArgumentException('non-nullable connector_start cannot be null');
        }
        $this->container['connector_start'] = $connector_start;

        return $this;
    }

    /**
     * Gets connector_end
     *
     * @return \OpenAPI\Client\Model\ConnectorEndpoint
     */
    public function getConnectorEnd()
    {
        return $this->container['connector_end'];
    }

    /**
     * Sets connector_end
     *
     * @param \OpenAPI\Client\Model\ConnectorEndpoint $connector_end The ending point of the connector.
     *
     * @return self
     */
    public function setConnectorEnd($connector_end)
    {
        if (is_null($connector_end)) {
            throw new \InvalidArgumentException('non-nullable connector_end cannot be null');
        }
        $this->container['connector_end'] = $connector_end;

        return $this;
    }

    /**
     * Gets connector_start_stroke_cap
     *
     * @return string
     */
    public function getConnectorStartStrokeCap()
    {
        return $this->container['connector_start_stroke_cap'];
    }

    /**
     * Sets connector_start_stroke_cap
     *
     * @param string $connector_start_stroke_cap A string enum describing the end cap of the start of the connector.
     *
     * @return self
     */
    public function setConnectorStartStrokeCap($connector_start_stroke_cap)
    {
        if (is_null($connector_start_stroke_cap)) {
            throw new \InvalidArgumentException('non-nullable connector_start_stroke_cap cannot be null');
        }
        $allowedValues = $this->getConnectorStartStrokeCapAllowableValues();
        if (!in_array($connector_start_stroke_cap, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'connector_start_stroke_cap', must be one of '%s'",
                    $connector_start_stroke_cap,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['connector_start_stroke_cap'] = $connector_start_stroke_cap;

        return $this;
    }

    /**
     * Gets connector_end_stroke_cap
     *
     * @return string
     */
    public function getConnectorEndStrokeCap()
    {
        return $this->container['connector_end_stroke_cap'];
    }

    /**
     * Sets connector_end_stroke_cap
     *
     * @param string $connector_end_stroke_cap A string enum describing the end cap of the end of the connector.
     *
     * @return self
     */
    public function setConnectorEndStrokeCap($connector_end_stroke_cap)
    {
        if (is_null($connector_end_stroke_cap)) {
            throw new \InvalidArgumentException('non-nullable connector_end_stroke_cap cannot be null');
        }
        $allowedValues = $this->getConnectorEndStrokeCapAllowableValues();
        if (!in_array($connector_end_stroke_cap, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'connector_end_stroke_cap', must be one of '%s'",
                    $connector_end_stroke_cap,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['connector_end_stroke_cap'] = $connector_end_stroke_cap;

        return $this;
    }

    /**
     * Gets connector_line_type
     *
     * @return \OpenAPI\Client\Model\ConnectorLineType
     */
    public function getConnectorLineType()
    {
        return $this->container['connector_line_type'];
    }

    /**
     * Sets connector_line_type
     *
     * @param \OpenAPI\Client\Model\ConnectorLineType $connector_line_type Connector line type.
     *
     * @return self
     */
    public function setConnectorLineType($connector_line_type)
    {
        if (is_null($connector_line_type)) {
            throw new \InvalidArgumentException('non-nullable connector_line_type cannot be null');
        }
        $this->container['connector_line_type'] = $connector_line_type;

        return $this;
    }

    /**
     * Gets text_background
     *
     * @return \OpenAPI\Client\Model\ConnectorTextBackground|null
     */
    public function getTextBackground()
    {
        return $this->container['text_background'];
    }

    /**
     * Sets text_background
     *
     * @param \OpenAPI\Client\Model\ConnectorTextBackground|null $text_background Connector text background.
     *
     * @return self
     */
    public function setTextBackground($text_background)
    {
        if (is_null($text_background)) {
            throw new \InvalidArgumentException('non-nullable text_background cannot be null');
        }
        $this->container['text_background'] = $text_background;

        return $this;
    }

    /**
     * Gets characters
     *
     * @return string
     */
    public function getCharacters()
    {
        return $this->container['characters'];
    }

    /**
     * Sets characters
     *
     * @param string $characters The raw characters in the text path node.
     *
     * @return self
     */
    public function setCharacters($characters)
    {
        if (is_null($characters)) {
            throw new \InvalidArgumentException('non-nullable characters cannot be null');
        }
        $this->container['characters'] = $characters;

        return $this;
    }

    /**
     * Gets arc_data
     *
     * @return \OpenAPI\Client\Model\ArcData
     */
    public function getArcData()
    {
        return $this->container['arc_data'];
    }

    /**
     * Sets arc_data
     *
     * @param \OpenAPI\Client\Model\ArcData $arc_data arc_data
     *
     * @return self
     */
    public function setArcData($arc_data)
    {
        if (is_null($arc_data)) {
            throw new \InvalidArgumentException('non-nullable arc_data cannot be null');
        }
        $this->container['arc_data'] = $arc_data;

        return $this;
    }

    /**
     * Gets component_id
     *
     * @return string
     */
    public function getComponentId()
    {
        return $this->container['component_id'];
    }

    /**
     * Sets component_id
     *
     * @param string $component_id ID of component that this instance came from.
     *
     * @return self
     */
    public function setComponentId($component_id)
    {
        if (is_null($component_id)) {
            throw new \InvalidArgumentException('non-nullable component_id cannot be null');
        }
        $this->container['component_id'] = $component_id;

        return $this;
    }

    /**
     * Gets is_exposed_instance
     *
     * @return bool|null
     */
    public function getIsExposedInstance()
    {
        return $this->container['is_exposed_instance'];
    }

    /**
     * Sets is_exposed_instance
     *
     * @param bool|null $is_exposed_instance If true, this node has been marked as exposed to its containing component or component set.
     *
     * @return self
     */
    public function setIsExposedInstance($is_exposed_instance)
    {
        if (is_null($is_exposed_instance)) {
            throw new \InvalidArgumentException('non-nullable is_exposed_instance cannot be null');
        }
        $this->container['is_exposed_instance'] = $is_exposed_instance;

        return $this;
    }

    /**
     * Gets exposed_instances
     *
     * @return string[]|null
     */
    public function getExposedInstances()
    {
        return $this->container['exposed_instances'];
    }

    /**
     * Sets exposed_instances
     *
     * @param string[]|null $exposed_instances IDs of instances that have been exposed to this node's level.
     *
     * @return self
     */
    public function setExposedInstances($exposed_instances)
    {
        if (is_null($exposed_instances)) {
            throw new \InvalidArgumentException('non-nullable exposed_instances cannot be null');
        }
        $this->container['exposed_instances'] = $exposed_instances;

        return $this;
    }

    /**
     * Gets component_properties
     *
     * @return array<string,\OpenAPI\Client\Model\ComponentProperty>|null
     */
    public function getComponentProperties()
    {
        return $this->container['component_properties'];
    }

    /**
     * Sets component_properties
     *
     * @param array<string,\OpenAPI\Client\Model\ComponentProperty>|null $component_properties A mapping of name to `ComponentProperty` for all component properties on this instance. Each property has a type, value, and other optional values.
     *
     * @return self
     */
    public function setComponentProperties($component_properties)
    {
        if (is_null($component_properties)) {
            throw new \InvalidArgumentException('non-nullable component_properties cannot be null');
        }
        $this->container['component_properties'] = $component_properties;

        return $this;
    }

    /**
     * Gets overrides
     *
     * @return \OpenAPI\Client\Model\Overrides[]
     */
    public function getOverrides()
    {
        return $this->container['overrides'];
    }

    /**
     * Sets overrides
     *
     * @param \OpenAPI\Client\Model\Overrides[] $overrides An array of all of the fields directly overridden on this instance. Inherited overrides are not included.
     *
     * @return self
     */
    public function setOverrides($overrides)
    {
        if (is_null($overrides)) {
            throw new \InvalidArgumentException('non-nullable overrides cannot be null');
        }
        $this->container['overrides'] = $overrides;

        return $this;
    }

    /**
     * Gets section_contents_hidden
     *
     * @return bool
     */
    public function getSectionContentsHidden()
    {
        return $this->container['section_contents_hidden'];
    }

    /**
     * Sets section_contents_hidden
     *
     * @param bool $section_contents_hidden Whether the contents of the section are visible
     *
     * @return self
     */
    public function setSectionContentsHidden($section_contents_hidden)
    {
        if (is_null($section_contents_hidden)) {
            throw new \InvalidArgumentException('non-nullable section_contents_hidden cannot be null');
        }
        $this->container['section_contents_hidden'] = $section_contents_hidden;

        return $this;
    }

    /**
     * Gets shape_type
     *
     * @return \OpenAPI\Client\Model\ShapeType
     */
    public function getShapeType()
    {
        return $this->container['shape_type'];
    }

    /**
     * Sets shape_type
     *
     * @param \OpenAPI\Client\Model\ShapeType $shape_type Geometric shape type. Most shape types have the same name as their tooltip but there are a few exceptions. ENG_DATABASE: Cylinder, ENG_QUEUE: Horizontal cylinder, ENG_FILE: File, ENG_FOLDER: Folder.
     *
     * @return self
     */
    public function setShapeType($shape_type)
    {
        if (is_null($shape_type)) {
            throw new \InvalidArgumentException('non-nullable shape_type cannot be null');
        }
        $this->container['shape_type'] = $shape_type;

        return $this;
    }

    /**
     * Gets author_visible
     *
     * @return bool|null
     */
    public function getAuthorVisible()
    {
        return $this->container['author_visible'];
    }

    /**
     * Sets author_visible
     *
     * @param bool|null $author_visible If true, author name is visible.
     *
     * @return self
     */
    public function setAuthorVisible($author_visible)
    {
        if (is_null($author_visible)) {
            throw new \InvalidArgumentException('non-nullable author_visible cannot be null');
        }
        $this->container['author_visible'] = $author_visible;

        return $this;
    }

    /**
     * Gets style
     *
     * @return \OpenAPI\Client\Model\TextPathTypeStyle
     */
    public function getStyle()
    {
        return $this->container['style'];
    }

    /**
     * Sets style
     *
     * @param \OpenAPI\Client\Model\TextPathTypeStyle $style Style of text including font family and weight.
     *
     * @return self
     */
    public function setStyle($style)
    {
        if (is_null($style)) {
            throw new \InvalidArgumentException('non-nullable style cannot be null');
        }
        $this->container['style'] = $style;

        return $this;
    }

    /**
     * Gets character_style_overrides
     *
     * @return float[]
     */
    public function getCharacterStyleOverrides()
    {
        return $this->container['character_style_overrides'];
    }

    /**
     * Sets character_style_overrides
     *
     * @param float[] $character_style_overrides The array corresponds to characters in the text box, where each element references the 'styleOverrideTable' to apply specific styles to each character. The array's length can be less than or equal to the number of characters due to the removal of trailing zeros. Elements with a value of 0 indicate characters that use the default type style. If the array is shorter than the total number of characters, the characters beyond the array's length also use the default style.
     *
     * @return self
     */
    public function setCharacterStyleOverrides($character_style_overrides)
    {
        if (is_null($character_style_overrides)) {
            throw new \InvalidArgumentException('non-nullable character_style_overrides cannot be null');
        }
        $this->container['character_style_overrides'] = $character_style_overrides;

        return $this;
    }

    /**
     * Gets layout_version
     *
     * @return float|null
     */
    public function getLayoutVersion()
    {
        return $this->container['layout_version'];
    }

    /**
     * Sets layout_version
     *
     * @param float|null $layout_version Internal property, preserved for backward compatibility. Avoid using this value.
     *
     * @return self
     */
    public function setLayoutVersion($layout_version)
    {
        if (is_null($layout_version)) {
            throw new \InvalidArgumentException('non-nullable layout_version cannot be null');
        }
        $this->container['layout_version'] = $layout_version;

        return $this;
    }

    /**
     * Gets style_override_table
     *
     * @return array<string,\OpenAPI\Client\Model\TextPathTypeStyle>
     */
    public function getStyleOverrideTable()
    {
        return $this->container['style_override_table'];
    }

    /**
     * Sets style_override_table
     *
     * @param array<string,\OpenAPI\Client\Model\TextPathTypeStyle> $style_override_table Map from ID to TextPathTypeStyle for looking up style overrides.
     *
     * @return self
     */
    public function setStyleOverrideTable($style_override_table)
    {
        if (is_null($style_override_table)) {
            throw new \InvalidArgumentException('non-nullable style_override_table cannot be null');
        }
        $this->container['style_override_table'] = $style_override_table;

        return $this;
    }

    /**
     * Gets line_types
     *
     * @return string[]
     */
    public function getLineTypes()
    {
        return $this->container['line_types'];
    }

    /**
     * Sets line_types
     *
     * @param string[] $line_types An array with the same number of elements as lines in the text node, where lines are delimited by newline or paragraph separator characters. Each element in the array corresponds to the list type of a specific line. List types are represented as string enums with one of these possible values:  - `NONE`: Not a list item. - `ORDERED`: Text is an ordered list (numbered). - `UNORDERED`: Text is an unordered list (bulleted).
     *
     * @return self
     */
    public function setLineTypes($line_types)
    {
        if (is_null($line_types)) {
            throw new \InvalidArgumentException('non-nullable line_types cannot be null');
        }
        $allowedValues = $this->getLineTypesAllowableValues();
        if (array_diff($line_types, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'line_types', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['line_types'] = $line_types;

        return $this;
    }

    /**
     * Gets line_indentations
     *
     * @return float[]
     */
    public function getLineIndentations()
    {
        return $this->container['line_indentations'];
    }

    /**
     * Sets line_indentations
     *
     * @param float[] $line_indentations An array with the same number of elements as lines in the text node, where lines are delimited by newline or paragraph separator characters. Each element in the array corresponds to the indentation level of a specific line.
     *
     * @return self
     */
    public function setLineIndentations($line_indentations)
    {
        if (is_null($line_indentations)) {
            throw new \InvalidArgumentException('non-nullable line_indentations cannot be null');
        }
        $this->container['line_indentations'] = $line_indentations;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


