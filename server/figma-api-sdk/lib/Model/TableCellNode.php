<?php
/**
 * TableCellNode
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.33.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * TableCellNode Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class TableCellNode implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'TableCellNode';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'string',
        'name' => 'string',
        'type' => 'string',
        'visible' => 'bool',
        'locked' => 'bool',
        'is_fixed' => 'bool',
        'scroll_behavior' => 'string',
        'rotation' => 'float',
        'component_property_references' => 'array<string,string>',
        'plugin_data' => 'mixed',
        'shared_plugin_data' => 'mixed',
        'bound_variables' => '\OpenAPI\Client\Model\IsLayerTraitBoundVariables',
        'explicit_variable_modes' => 'array<string,string>',
        'fills' => '\OpenAPI\Client\Model\Paint[]',
        'styles' => 'array<string,string>',
        'absolute_bounding_box' => '\OpenAPI\Client\Model\Rectangle',
        'absolute_render_bounds' => '\OpenAPI\Client\Model\Rectangle',
        'preserve_ratio' => 'bool',
        'constraints' => '\OpenAPI\Client\Model\LayoutConstraint',
        'relative_transform' => 'float[][]',
        'size' => '\OpenAPI\Client\Model\Vector',
        'layout_align' => 'string',
        'layout_grow' => 'float',
        'layout_positioning' => 'string',
        'min_width' => 'float',
        'max_width' => 'float',
        'min_height' => 'float',
        'max_height' => 'float',
        'layout_sizing_horizontal' => 'string',
        'layout_sizing_vertical' => 'string',
        'grid_row_count' => 'float',
        'grid_column_count' => 'float',
        'grid_row_gap' => 'float',
        'grid_column_gap' => 'float',
        'grid_columns_sizing' => 'string',
        'grid_rows_sizing' => 'string',
        'grid_child_horizontal_align' => 'string',
        'grid_child_vertical_align' => 'string',
        'grid_row_span' => 'float',
        'grid_column_span' => 'float',
        'grid_row_anchor_index' => 'float',
        'grid_column_anchor_index' => 'float',
        'characters' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => null,
        'name' => null,
        'type' => null,
        'visible' => null,
        'locked' => null,
        'is_fixed' => null,
        'scroll_behavior' => null,
        'rotation' => null,
        'component_property_references' => null,
        'plugin_data' => null,
        'shared_plugin_data' => null,
        'bound_variables' => null,
        'explicit_variable_modes' => null,
        'fills' => null,
        'styles' => null,
        'absolute_bounding_box' => null,
        'absolute_render_bounds' => null,
        'preserve_ratio' => null,
        'constraints' => null,
        'relative_transform' => null,
        'size' => null,
        'layout_align' => null,
        'layout_grow' => null,
        'layout_positioning' => null,
        'min_width' => null,
        'max_width' => null,
        'min_height' => null,
        'max_height' => null,
        'layout_sizing_horizontal' => null,
        'layout_sizing_vertical' => null,
        'grid_row_count' => null,
        'grid_column_count' => null,
        'grid_row_gap' => null,
        'grid_column_gap' => null,
        'grid_columns_sizing' => null,
        'grid_rows_sizing' => null,
        'grid_child_horizontal_align' => null,
        'grid_child_vertical_align' => null,
        'grid_row_span' => null,
        'grid_column_span' => null,
        'grid_row_anchor_index' => null,
        'grid_column_anchor_index' => null,
        'characters' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
        'name' => false,
        'type' => false,
        'visible' => false,
        'locked' => false,
        'is_fixed' => false,
        'scroll_behavior' => false,
        'rotation' => false,
        'component_property_references' => false,
        'plugin_data' => true,
        'shared_plugin_data' => true,
        'bound_variables' => false,
        'explicit_variable_modes' => false,
        'fills' => false,
        'styles' => false,
        'absolute_bounding_box' => false,
        'absolute_render_bounds' => false,
        'preserve_ratio' => false,
        'constraints' => false,
        'relative_transform' => false,
        'size' => false,
        'layout_align' => false,
        'layout_grow' => false,
        'layout_positioning' => false,
        'min_width' => false,
        'max_width' => false,
        'min_height' => false,
        'max_height' => false,
        'layout_sizing_horizontal' => false,
        'layout_sizing_vertical' => false,
        'grid_row_count' => false,
        'grid_column_count' => false,
        'grid_row_gap' => false,
        'grid_column_gap' => false,
        'grid_columns_sizing' => false,
        'grid_rows_sizing' => false,
        'grid_child_horizontal_align' => false,
        'grid_child_vertical_align' => false,
        'grid_row_span' => false,
        'grid_column_span' => false,
        'grid_row_anchor_index' => false,
        'grid_column_anchor_index' => false,
        'characters' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'name' => 'name',
        'type' => 'type',
        'visible' => 'visible',
        'locked' => 'locked',
        'is_fixed' => 'isFixed',
        'scroll_behavior' => 'scrollBehavior',
        'rotation' => 'rotation',
        'component_property_references' => 'componentPropertyReferences',
        'plugin_data' => 'pluginData',
        'shared_plugin_data' => 'sharedPluginData',
        'bound_variables' => 'boundVariables',
        'explicit_variable_modes' => 'explicitVariableModes',
        'fills' => 'fills',
        'styles' => 'styles',
        'absolute_bounding_box' => 'absoluteBoundingBox',
        'absolute_render_bounds' => 'absoluteRenderBounds',
        'preserve_ratio' => 'preserveRatio',
        'constraints' => 'constraints',
        'relative_transform' => 'relativeTransform',
        'size' => 'size',
        'layout_align' => 'layoutAlign',
        'layout_grow' => 'layoutGrow',
        'layout_positioning' => 'layoutPositioning',
        'min_width' => 'minWidth',
        'max_width' => 'maxWidth',
        'min_height' => 'minHeight',
        'max_height' => 'maxHeight',
        'layout_sizing_horizontal' => 'layoutSizingHorizontal',
        'layout_sizing_vertical' => 'layoutSizingVertical',
        'grid_row_count' => 'gridRowCount',
        'grid_column_count' => 'gridColumnCount',
        'grid_row_gap' => 'gridRowGap',
        'grid_column_gap' => 'gridColumnGap',
        'grid_columns_sizing' => 'gridColumnsSizing',
        'grid_rows_sizing' => 'gridRowsSizing',
        'grid_child_horizontal_align' => 'gridChildHorizontalAlign',
        'grid_child_vertical_align' => 'gridChildVerticalAlign',
        'grid_row_span' => 'gridRowSpan',
        'grid_column_span' => 'gridColumnSpan',
        'grid_row_anchor_index' => 'gridRowAnchorIndex',
        'grid_column_anchor_index' => 'gridColumnAnchorIndex',
        'characters' => 'characters'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'name' => 'setName',
        'type' => 'setType',
        'visible' => 'setVisible',
        'locked' => 'setLocked',
        'is_fixed' => 'setIsFixed',
        'scroll_behavior' => 'setScrollBehavior',
        'rotation' => 'setRotation',
        'component_property_references' => 'setComponentPropertyReferences',
        'plugin_data' => 'setPluginData',
        'shared_plugin_data' => 'setSharedPluginData',
        'bound_variables' => 'setBoundVariables',
        'explicit_variable_modes' => 'setExplicitVariableModes',
        'fills' => 'setFills',
        'styles' => 'setStyles',
        'absolute_bounding_box' => 'setAbsoluteBoundingBox',
        'absolute_render_bounds' => 'setAbsoluteRenderBounds',
        'preserve_ratio' => 'setPreserveRatio',
        'constraints' => 'setConstraints',
        'relative_transform' => 'setRelativeTransform',
        'size' => 'setSize',
        'layout_align' => 'setLayoutAlign',
        'layout_grow' => 'setLayoutGrow',
        'layout_positioning' => 'setLayoutPositioning',
        'min_width' => 'setMinWidth',
        'max_width' => 'setMaxWidth',
        'min_height' => 'setMinHeight',
        'max_height' => 'setMaxHeight',
        'layout_sizing_horizontal' => 'setLayoutSizingHorizontal',
        'layout_sizing_vertical' => 'setLayoutSizingVertical',
        'grid_row_count' => 'setGridRowCount',
        'grid_column_count' => 'setGridColumnCount',
        'grid_row_gap' => 'setGridRowGap',
        'grid_column_gap' => 'setGridColumnGap',
        'grid_columns_sizing' => 'setGridColumnsSizing',
        'grid_rows_sizing' => 'setGridRowsSizing',
        'grid_child_horizontal_align' => 'setGridChildHorizontalAlign',
        'grid_child_vertical_align' => 'setGridChildVerticalAlign',
        'grid_row_span' => 'setGridRowSpan',
        'grid_column_span' => 'setGridColumnSpan',
        'grid_row_anchor_index' => 'setGridRowAnchorIndex',
        'grid_column_anchor_index' => 'setGridColumnAnchorIndex',
        'characters' => 'setCharacters'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'name' => 'getName',
        'type' => 'getType',
        'visible' => 'getVisible',
        'locked' => 'getLocked',
        'is_fixed' => 'getIsFixed',
        'scroll_behavior' => 'getScrollBehavior',
        'rotation' => 'getRotation',
        'component_property_references' => 'getComponentPropertyReferences',
        'plugin_data' => 'getPluginData',
        'shared_plugin_data' => 'getSharedPluginData',
        'bound_variables' => 'getBoundVariables',
        'explicit_variable_modes' => 'getExplicitVariableModes',
        'fills' => 'getFills',
        'styles' => 'getStyles',
        'absolute_bounding_box' => 'getAbsoluteBoundingBox',
        'absolute_render_bounds' => 'getAbsoluteRenderBounds',
        'preserve_ratio' => 'getPreserveRatio',
        'constraints' => 'getConstraints',
        'relative_transform' => 'getRelativeTransform',
        'size' => 'getSize',
        'layout_align' => 'getLayoutAlign',
        'layout_grow' => 'getLayoutGrow',
        'layout_positioning' => 'getLayoutPositioning',
        'min_width' => 'getMinWidth',
        'max_width' => 'getMaxWidth',
        'min_height' => 'getMinHeight',
        'max_height' => 'getMaxHeight',
        'layout_sizing_horizontal' => 'getLayoutSizingHorizontal',
        'layout_sizing_vertical' => 'getLayoutSizingVertical',
        'grid_row_count' => 'getGridRowCount',
        'grid_column_count' => 'getGridColumnCount',
        'grid_row_gap' => 'getGridRowGap',
        'grid_column_gap' => 'getGridColumnGap',
        'grid_columns_sizing' => 'getGridColumnsSizing',
        'grid_rows_sizing' => 'getGridRowsSizing',
        'grid_child_horizontal_align' => 'getGridChildHorizontalAlign',
        'grid_child_vertical_align' => 'getGridChildVerticalAlign',
        'grid_row_span' => 'getGridRowSpan',
        'grid_column_span' => 'getGridColumnSpan',
        'grid_row_anchor_index' => 'getGridRowAnchorIndex',
        'grid_column_anchor_index' => 'getGridColumnAnchorIndex',
        'characters' => 'getCharacters'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_TABLE_CELL = 'TABLE_CELL';
    public const SCROLL_BEHAVIOR_SCROLLS = 'SCROLLS';
    public const SCROLL_BEHAVIOR_FIXED = 'FIXED';
    public const SCROLL_BEHAVIOR_STICKY_SCROLLS = 'STICKY_SCROLLS';
    public const LAYOUT_ALIGN_INHERIT = 'INHERIT';
    public const LAYOUT_ALIGN_STRETCH = 'STRETCH';
    public const LAYOUT_ALIGN_MIN = 'MIN';
    public const LAYOUT_ALIGN_CENTER = 'CENTER';
    public const LAYOUT_ALIGN_MAX = 'MAX';
    public const LAYOUT_GROW_NUMBER_0 = 0;
    public const LAYOUT_GROW_NUMBER_1 = 1;
    public const LAYOUT_POSITIONING_AUTO = 'AUTO';
    public const LAYOUT_POSITIONING_ABSOLUTE = 'ABSOLUTE';
    public const LAYOUT_SIZING_HORIZONTAL_FIXED = 'FIXED';
    public const LAYOUT_SIZING_HORIZONTAL_HUG = 'HUG';
    public const LAYOUT_SIZING_HORIZONTAL_FILL = 'FILL';
    public const LAYOUT_SIZING_VERTICAL_FIXED = 'FIXED';
    public const LAYOUT_SIZING_VERTICAL_HUG = 'HUG';
    public const LAYOUT_SIZING_VERTICAL_FILL = 'FILL';
    public const GRID_CHILD_HORIZONTAL_ALIGN_AUTO = 'AUTO';
    public const GRID_CHILD_HORIZONTAL_ALIGN_MIN = 'MIN';
    public const GRID_CHILD_HORIZONTAL_ALIGN_CENTER = 'CENTER';
    public const GRID_CHILD_HORIZONTAL_ALIGN_MAX = 'MAX';
    public const GRID_CHILD_VERTICAL_ALIGN_AUTO = 'AUTO';
    public const GRID_CHILD_VERTICAL_ALIGN_MIN = 'MIN';
    public const GRID_CHILD_VERTICAL_ALIGN_CENTER = 'CENTER';
    public const GRID_CHILD_VERTICAL_ALIGN_MAX = 'MAX';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_TABLE_CELL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScrollBehaviorAllowableValues()
    {
        return [
            self::SCROLL_BEHAVIOR_SCROLLS,
            self::SCROLL_BEHAVIOR_FIXED,
            self::SCROLL_BEHAVIOR_STICKY_SCROLLS,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutAlignAllowableValues()
    {
        return [
            self::LAYOUT_ALIGN_INHERIT,
            self::LAYOUT_ALIGN_STRETCH,
            self::LAYOUT_ALIGN_MIN,
            self::LAYOUT_ALIGN_CENTER,
            self::LAYOUT_ALIGN_MAX,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutGrowAllowableValues()
    {
        return [
            self::LAYOUT_GROW_NUMBER_0,
            self::LAYOUT_GROW_NUMBER_1,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutPositioningAllowableValues()
    {
        return [
            self::LAYOUT_POSITIONING_AUTO,
            self::LAYOUT_POSITIONING_ABSOLUTE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutSizingHorizontalAllowableValues()
    {
        return [
            self::LAYOUT_SIZING_HORIZONTAL_FIXED,
            self::LAYOUT_SIZING_HORIZONTAL_HUG,
            self::LAYOUT_SIZING_HORIZONTAL_FILL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getLayoutSizingVerticalAllowableValues()
    {
        return [
            self::LAYOUT_SIZING_VERTICAL_FIXED,
            self::LAYOUT_SIZING_VERTICAL_HUG,
            self::LAYOUT_SIZING_VERTICAL_FILL,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGridChildHorizontalAlignAllowableValues()
    {
        return [
            self::GRID_CHILD_HORIZONTAL_ALIGN_AUTO,
            self::GRID_CHILD_HORIZONTAL_ALIGN_MIN,
            self::GRID_CHILD_HORIZONTAL_ALIGN_CENTER,
            self::GRID_CHILD_HORIZONTAL_ALIGN_MAX,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getGridChildVerticalAlignAllowableValues()
    {
        return [
            self::GRID_CHILD_VERTICAL_ALIGN_AUTO,
            self::GRID_CHILD_VERTICAL_ALIGN_MIN,
            self::GRID_CHILD_VERTICAL_ALIGN_CENTER,
            self::GRID_CHILD_VERTICAL_ALIGN_MAX,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('name', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('visible', $data ?? [], true);
        $this->setIfExists('locked', $data ?? [], false);
        $this->setIfExists('is_fixed', $data ?? [], false);
        $this->setIfExists('scroll_behavior', $data ?? [], 'SCROLLS');
        $this->setIfExists('rotation', $data ?? [], 0);
        $this->setIfExists('component_property_references', $data ?? [], null);
        $this->setIfExists('plugin_data', $data ?? [], null);
        $this->setIfExists('shared_plugin_data', $data ?? [], null);
        $this->setIfExists('bound_variables', $data ?? [], null);
        $this->setIfExists('explicit_variable_modes', $data ?? [], null);
        $this->setIfExists('fills', $data ?? [], null);
        $this->setIfExists('styles', $data ?? [], null);
        $this->setIfExists('absolute_bounding_box', $data ?? [], null);
        $this->setIfExists('absolute_render_bounds', $data ?? [], null);
        $this->setIfExists('preserve_ratio', $data ?? [], false);
        $this->setIfExists('constraints', $data ?? [], null);
        $this->setIfExists('relative_transform', $data ?? [], null);
        $this->setIfExists('size', $data ?? [], null);
        $this->setIfExists('layout_align', $data ?? [], null);
        $this->setIfExists('layout_grow', $data ?? [], self::LAYOUT_GROW_NUMBER_0);
        $this->setIfExists('layout_positioning', $data ?? [], 'AUTO');
        $this->setIfExists('min_width', $data ?? [], 0);
        $this->setIfExists('max_width', $data ?? [], 0);
        $this->setIfExists('min_height', $data ?? [], 0);
        $this->setIfExists('max_height', $data ?? [], 0);
        $this->setIfExists('layout_sizing_horizontal', $data ?? [], null);
        $this->setIfExists('layout_sizing_vertical', $data ?? [], null);
        $this->setIfExists('grid_row_count', $data ?? [], null);
        $this->setIfExists('grid_column_count', $data ?? [], null);
        $this->setIfExists('grid_row_gap', $data ?? [], 0);
        $this->setIfExists('grid_column_gap', $data ?? [], 0);
        $this->setIfExists('grid_columns_sizing', $data ?? [], null);
        $this->setIfExists('grid_rows_sizing', $data ?? [], null);
        $this->setIfExists('grid_child_horizontal_align', $data ?? [], null);
        $this->setIfExists('grid_child_vertical_align', $data ?? [], null);
        $this->setIfExists('grid_row_span', $data ?? [], 1);
        $this->setIfExists('grid_column_span', $data ?? [], 1);
        $this->setIfExists('grid_row_anchor_index', $data ?? [], 0);
        $this->setIfExists('grid_column_anchor_index', $data ?? [], 0);
        $this->setIfExists('characters', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['scroll_behavior'] === null) {
            $invalidProperties[] = "'scroll_behavior' can't be null";
        }
        $allowedValues = $this->getScrollBehaviorAllowableValues();
        if (!is_null($this->container['scroll_behavior']) && !in_array($this->container['scroll_behavior'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scroll_behavior', must be one of '%s'",
                $this->container['scroll_behavior'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['fills'] === null) {
            $invalidProperties[] = "'fills' can't be null";
        }
        if ($this->container['absolute_bounding_box'] === null) {
            $invalidProperties[] = "'absolute_bounding_box' can't be null";
        }
        if ($this->container['absolute_render_bounds'] === null) {
            $invalidProperties[] = "'absolute_render_bounds' can't be null";
        }
        if (!is_null($this->container['relative_transform']) && (count($this->container['relative_transform']) > 2)) {
            $invalidProperties[] = "invalid value for 'relative_transform', number of items must be less than or equal to 2.";
        }

        if (!is_null($this->container['relative_transform']) && (count($this->container['relative_transform']) < 2)) {
            $invalidProperties[] = "invalid value for 'relative_transform', number of items must be greater than or equal to 2.";
        }

        $allowedValues = $this->getLayoutAlignAllowableValues();
        if (!is_null($this->container['layout_align']) && !in_array($this->container['layout_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_align', must be one of '%s'",
                $this->container['layout_align'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutGrowAllowableValues();
        if (!is_null($this->container['layout_grow']) && !in_array($this->container['layout_grow'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_grow', must be one of '%s'",
                $this->container['layout_grow'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutPositioningAllowableValues();
        if (!is_null($this->container['layout_positioning']) && !in_array($this->container['layout_positioning'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_positioning', must be one of '%s'",
                $this->container['layout_positioning'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutSizingHorizontalAllowableValues();
        if (!is_null($this->container['layout_sizing_horizontal']) && !in_array($this->container['layout_sizing_horizontal'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_sizing_horizontal', must be one of '%s'",
                $this->container['layout_sizing_horizontal'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getLayoutSizingVerticalAllowableValues();
        if (!is_null($this->container['layout_sizing_vertical']) && !in_array($this->container['layout_sizing_vertical'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'layout_sizing_vertical', must be one of '%s'",
                $this->container['layout_sizing_vertical'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getGridChildHorizontalAlignAllowableValues();
        if (!is_null($this->container['grid_child_horizontal_align']) && !in_array($this->container['grid_child_horizontal_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'grid_child_horizontal_align', must be one of '%s'",
                $this->container['grid_child_horizontal_align'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getGridChildVerticalAlignAllowableValues();
        if (!is_null($this->container['grid_child_vertical_align']) && !in_array($this->container['grid_child_vertical_align'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'grid_child_vertical_align', must be one of '%s'",
                $this->container['grid_child_vertical_align'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['characters'] === null) {
            $invalidProperties[] = "'characters' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id A string uniquely identifying this node within the document.
     *
     * @return self
     */
    public function setId($id)
    {
        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name given to the node by the user in the tool.
     *
     * @return self
     */
    public function setName($name)
    {
        if (is_null($name)) {
            throw new \InvalidArgumentException('non-nullable name cannot be null');
        }
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type The type of this node, represented by the string literal \"TABLE_CELL\"
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible Whether or not the node is visible on the canvas.
     *
     * @return self
     */
    public function setVisible($visible)
    {
        if (is_null($visible)) {
            throw new \InvalidArgumentException('non-nullable visible cannot be null');
        }
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets locked
     *
     * @return bool|null
     */
    public function getLocked()
    {
        return $this->container['locked'];
    }

    /**
     * Sets locked
     *
     * @param bool|null $locked If true, layer is locked and cannot be edited
     *
     * @return self
     */
    public function setLocked($locked)
    {
        if (is_null($locked)) {
            throw new \InvalidArgumentException('non-nullable locked cannot be null');
        }
        $this->container['locked'] = $locked;

        return $this;
    }

    /**
     * Gets is_fixed
     *
     * @return bool|null
     * @deprecated
     */
    public function getIsFixed()
    {
        return $this->container['is_fixed'];
    }

    /**
     * Sets is_fixed
     *
     * @param bool|null $is_fixed Whether the layer is fixed while the parent is scrolling
     *
     * @return self
     * @deprecated
     */
    public function setIsFixed($is_fixed)
    {
        if (is_null($is_fixed)) {
            throw new \InvalidArgumentException('non-nullable is_fixed cannot be null');
        }
        $this->container['is_fixed'] = $is_fixed;

        return $this;
    }

    /**
     * Gets scroll_behavior
     *
     * @return string
     */
    public function getScrollBehavior()
    {
        return $this->container['scroll_behavior'];
    }

    /**
     * Sets scroll_behavior
     *
     * @param string $scroll_behavior How layer should be treated when the frame is resized
     *
     * @return self
     */
    public function setScrollBehavior($scroll_behavior)
    {
        if (is_null($scroll_behavior)) {
            throw new \InvalidArgumentException('non-nullable scroll_behavior cannot be null');
        }
        $allowedValues = $this->getScrollBehaviorAllowableValues();
        if (!in_array($scroll_behavior, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scroll_behavior', must be one of '%s'",
                    $scroll_behavior,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scroll_behavior'] = $scroll_behavior;

        return $this;
    }

    /**
     * Gets rotation
     *
     * @return float|null
     */
    public function getRotation()
    {
        return $this->container['rotation'];
    }

    /**
     * Sets rotation
     *
     * @param float|null $rotation The rotation of the node, if not 0.
     *
     * @return self
     */
    public function setRotation($rotation)
    {
        if (is_null($rotation)) {
            throw new \InvalidArgumentException('non-nullable rotation cannot be null');
        }
        $this->container['rotation'] = $rotation;

        return $this;
    }

    /**
     * Gets component_property_references
     *
     * @return array<string,string>|null
     */
    public function getComponentPropertyReferences()
    {
        return $this->container['component_property_references'];
    }

    /**
     * Sets component_property_references
     *
     * @param array<string,string>|null $component_property_references A mapping of a layer's property to component property name of component properties attached to this node. The component property name can be used to look up more information on the corresponding component's or component set's componentPropertyDefinitions.
     *
     * @return self
     */
    public function setComponentPropertyReferences($component_property_references)
    {
        if (is_null($component_property_references)) {
            throw new \InvalidArgumentException('non-nullable component_property_references cannot be null');
        }
        $this->container['component_property_references'] = $component_property_references;

        return $this;
    }

    /**
     * Gets plugin_data
     *
     * @return mixed|null
     */
    public function getPluginData()
    {
        return $this->container['plugin_data'];
    }

    /**
     * Sets plugin_data
     *
     * @param mixed|null $plugin_data plugin_data
     *
     * @return self
     */
    public function setPluginData($plugin_data)
    {
        if (is_null($plugin_data)) {
            array_push($this->openAPINullablesSetToNull, 'plugin_data');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('plugin_data', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['plugin_data'] = $plugin_data;

        return $this;
    }

    /**
     * Gets shared_plugin_data
     *
     * @return mixed|null
     */
    public function getSharedPluginData()
    {
        return $this->container['shared_plugin_data'];
    }

    /**
     * Sets shared_plugin_data
     *
     * @param mixed|null $shared_plugin_data shared_plugin_data
     *
     * @return self
     */
    public function setSharedPluginData($shared_plugin_data)
    {
        if (is_null($shared_plugin_data)) {
            array_push($this->openAPINullablesSetToNull, 'shared_plugin_data');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('shared_plugin_data', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }
        $this->container['shared_plugin_data'] = $shared_plugin_data;

        return $this;
    }

    /**
     * Gets bound_variables
     *
     * @return \OpenAPI\Client\Model\IsLayerTraitBoundVariables|null
     */
    public function getBoundVariables()
    {
        return $this->container['bound_variables'];
    }

    /**
     * Sets bound_variables
     *
     * @param \OpenAPI\Client\Model\IsLayerTraitBoundVariables|null $bound_variables bound_variables
     *
     * @return self
     */
    public function setBoundVariables($bound_variables)
    {
        if (is_null($bound_variables)) {
            throw new \InvalidArgumentException('non-nullable bound_variables cannot be null');
        }
        $this->container['bound_variables'] = $bound_variables;

        return $this;
    }

    /**
     * Gets explicit_variable_modes
     *
     * @return array<string,string>|null
     */
    public function getExplicitVariableModes()
    {
        return $this->container['explicit_variable_modes'];
    }

    /**
     * Sets explicit_variable_modes
     *
     * @param array<string,string>|null $explicit_variable_modes A mapping of variable collection ID to mode ID representing the explicitly set modes for this node.
     *
     * @return self
     */
    public function setExplicitVariableModes($explicit_variable_modes)
    {
        if (is_null($explicit_variable_modes)) {
            throw new \InvalidArgumentException('non-nullable explicit_variable_modes cannot be null');
        }
        $this->container['explicit_variable_modes'] = $explicit_variable_modes;

        return $this;
    }

    /**
     * Gets fills
     *
     * @return \OpenAPI\Client\Model\Paint[]
     */
    public function getFills()
    {
        return $this->container['fills'];
    }

    /**
     * Sets fills
     *
     * @param \OpenAPI\Client\Model\Paint[] $fills An array of fill paints applied to the node.
     *
     * @return self
     */
    public function setFills($fills)
    {
        if (is_null($fills)) {
            throw new \InvalidArgumentException('non-nullable fills cannot be null');
        }
        $this->container['fills'] = $fills;

        return $this;
    }

    /**
     * Gets styles
     *
     * @return array<string,string>|null
     */
    public function getStyles()
    {
        return $this->container['styles'];
    }

    /**
     * Sets styles
     *
     * @param array<string,string>|null $styles A mapping of a StyleType to style ID (see Style) of styles present on this node. The style ID can be used to look up more information about the style in the top-level styles field.
     *
     * @return self
     */
    public function setStyles($styles)
    {
        if (is_null($styles)) {
            throw new \InvalidArgumentException('non-nullable styles cannot be null');
        }
        $this->container['styles'] = $styles;

        return $this;
    }

    /**
     * Gets absolute_bounding_box
     *
     * @return \OpenAPI\Client\Model\Rectangle
     */
    public function getAbsoluteBoundingBox()
    {
        return $this->container['absolute_bounding_box'];
    }

    /**
     * Sets absolute_bounding_box
     *
     * @param \OpenAPI\Client\Model\Rectangle $absolute_bounding_box absolute_bounding_box
     *
     * @return self
     */
    public function setAbsoluteBoundingBox($absolute_bounding_box)
    {
        if (is_null($absolute_bounding_box)) {
            throw new \InvalidArgumentException('non-nullable absolute_bounding_box cannot be null');
        }
        $this->container['absolute_bounding_box'] = $absolute_bounding_box;

        return $this;
    }

    /**
     * Gets absolute_render_bounds
     *
     * @return \OpenAPI\Client\Model\Rectangle
     */
    public function getAbsoluteRenderBounds()
    {
        return $this->container['absolute_render_bounds'];
    }

    /**
     * Sets absolute_render_bounds
     *
     * @param \OpenAPI\Client\Model\Rectangle $absolute_render_bounds absolute_render_bounds
     *
     * @return self
     */
    public function setAbsoluteRenderBounds($absolute_render_bounds)
    {
        if (is_null($absolute_render_bounds)) {
            throw new \InvalidArgumentException('non-nullable absolute_render_bounds cannot be null');
        }
        $this->container['absolute_render_bounds'] = $absolute_render_bounds;

        return $this;
    }

    /**
     * Gets preserve_ratio
     *
     * @return bool|null
     */
    public function getPreserveRatio()
    {
        return $this->container['preserve_ratio'];
    }

    /**
     * Sets preserve_ratio
     *
     * @param bool|null $preserve_ratio Keep height and width constrained to same ratio.
     *
     * @return self
     */
    public function setPreserveRatio($preserve_ratio)
    {
        if (is_null($preserve_ratio)) {
            throw new \InvalidArgumentException('non-nullable preserve_ratio cannot be null');
        }
        $this->container['preserve_ratio'] = $preserve_ratio;

        return $this;
    }

    /**
     * Gets constraints
     *
     * @return \OpenAPI\Client\Model\LayoutConstraint|null
     */
    public function getConstraints()
    {
        return $this->container['constraints'];
    }

    /**
     * Sets constraints
     *
     * @param \OpenAPI\Client\Model\LayoutConstraint|null $constraints Horizontal and vertical layout constraints for node.
     *
     * @return self
     */
    public function setConstraints($constraints)
    {
        if (is_null($constraints)) {
            throw new \InvalidArgumentException('non-nullable constraints cannot be null');
        }
        $this->container['constraints'] = $constraints;

        return $this;
    }

    /**
     * Gets relative_transform
     *
     * @return float[][]|null
     */
    public function getRelativeTransform()
    {
        return $this->container['relative_transform'];
    }

    /**
     * Sets relative_transform
     *
     * @param float[][]|null $relative_transform A transformation matrix is standard way in computer graphics to represent translation and rotation. These are the top two rows of a 3x3 matrix. The bottom row of the matrix is assumed to be [0, 0, 1]. This is known as an affine transform and is enough to represent translation, rotation, and skew.  The identity transform is [[1, 0, 0], [0, 1, 0]].  A translation matrix will typically look like:  ``` [[1, 0, tx],   [0, 1, ty]] ```  and a rotation matrix will typically look like:  ``` [[cos(angle), sin(angle), 0],   [-sin(angle), cos(angle), 0]] ```  Another way to think about this transform is as three vectors:  - The x axis (t[0][0], t[1][0]) - The y axis (t[0][1], t[1][1]) - The translation offset (t[0][2], t[1][2])  The most common usage of the Transform matrix is the `relativeTransform property`. This particular usage of the matrix has a few additional restrictions. The translation offset can take on any value but we do enforce that the axis vectors are unit vectors (i.e. have length 1). The axes are not required to be at 90° angles to each other.
     *
     * @return self
     */
    public function setRelativeTransform($relative_transform)
    {
        if (is_null($relative_transform)) {
            throw new \InvalidArgumentException('non-nullable relative_transform cannot be null');
        }

        if ((count($relative_transform) > 2)) {
            throw new \InvalidArgumentException('invalid value for $relative_transform when calling TableCellNode., number of items must be less than or equal to 2.');
        }
        if ((count($relative_transform) < 2)) {
            throw new \InvalidArgumentException('invalid length for $relative_transform when calling TableCellNode., number of items must be greater than or equal to 2.');
        }
        $this->container['relative_transform'] = $relative_transform;

        return $this;
    }

    /**
     * Gets size
     *
     * @return \OpenAPI\Client\Model\Vector|null
     */
    public function getSize()
    {
        return $this->container['size'];
    }

    /**
     * Sets size
     *
     * @param \OpenAPI\Client\Model\Vector|null $size Width and height of element. This is different from the width and height of the bounding box in that the absolute bounding box represents the element after scaling and rotation. Only present if `geometry=paths` is passed.
     *
     * @return self
     */
    public function setSize($size)
    {
        if (is_null($size)) {
            throw new \InvalidArgumentException('non-nullable size cannot be null');
        }
        $this->container['size'] = $size;

        return $this;
    }

    /**
     * Gets layout_align
     *
     * @return string|null
     */
    public function getLayoutAlign()
    {
        return $this->container['layout_align'];
    }

    /**
     * Sets layout_align
     *
     * @param string|null $layout_align Determines if the layer should stretch along the parent's counter axis. This property is only provided for direct children of auto-layout frames.  - `INHERIT` - `STRETCH`  In previous versions of auto layout, determined how the layer is aligned inside an auto-layout frame. This property is only provided for direct children of auto-layout frames.  - `MIN` - `CENTER` - `MAX` - `STRETCH`  In horizontal auto-layout frames, \"MIN\" and \"MAX\" correspond to \"TOP\" and \"BOTTOM\". In vertical auto-layout frames, \"MIN\" and \"MAX\" correspond to \"LEFT\" and \"RIGHT\".
     *
     * @return self
     */
    public function setLayoutAlign($layout_align)
    {
        if (is_null($layout_align)) {
            throw new \InvalidArgumentException('non-nullable layout_align cannot be null');
        }
        $allowedValues = $this->getLayoutAlignAllowableValues();
        if (!in_array($layout_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_align', must be one of '%s'",
                    $layout_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_align'] = $layout_align;

        return $this;
    }

    /**
     * Gets layout_grow
     *
     * @return float|null
     */
    public function getLayoutGrow()
    {
        return $this->container['layout_grow'];
    }

    /**
     * Sets layout_grow
     *
     * @param float|null $layout_grow This property is applicable only for direct children of auto-layout frames, ignored otherwise. Determines whether a layer should stretch along the parent's primary axis. A `0` corresponds to a fixed size and `1` corresponds to stretch.
     *
     * @return self
     */
    public function setLayoutGrow($layout_grow)
    {
        if (is_null($layout_grow)) {
            throw new \InvalidArgumentException('non-nullable layout_grow cannot be null');
        }
        $allowedValues = $this->getLayoutGrowAllowableValues();
        if (!in_array($layout_grow, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_grow', must be one of '%s'",
                    $layout_grow,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_grow'] = $layout_grow;

        return $this;
    }

    /**
     * Gets layout_positioning
     *
     * @return string|null
     */
    public function getLayoutPositioning()
    {
        return $this->container['layout_positioning'];
    }

    /**
     * Sets layout_positioning
     *
     * @param string|null $layout_positioning Determines whether a layer's size and position should be determined by auto-layout settings or manually adjustable.
     *
     * @return self
     */
    public function setLayoutPositioning($layout_positioning)
    {
        if (is_null($layout_positioning)) {
            throw new \InvalidArgumentException('non-nullable layout_positioning cannot be null');
        }
        $allowedValues = $this->getLayoutPositioningAllowableValues();
        if (!in_array($layout_positioning, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_positioning', must be one of '%s'",
                    $layout_positioning,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_positioning'] = $layout_positioning;

        return $this;
    }

    /**
     * Gets min_width
     *
     * @return float|null
     */
    public function getMinWidth()
    {
        return $this->container['min_width'];
    }

    /**
     * Sets min_width
     *
     * @param float|null $min_width The minimum width of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMinWidth($min_width)
    {
        if (is_null($min_width)) {
            throw new \InvalidArgumentException('non-nullable min_width cannot be null');
        }
        $this->container['min_width'] = $min_width;

        return $this;
    }

    /**
     * Gets max_width
     *
     * @return float|null
     */
    public function getMaxWidth()
    {
        return $this->container['max_width'];
    }

    /**
     * Sets max_width
     *
     * @param float|null $max_width The maximum width of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMaxWidth($max_width)
    {
        if (is_null($max_width)) {
            throw new \InvalidArgumentException('non-nullable max_width cannot be null');
        }
        $this->container['max_width'] = $max_width;

        return $this;
    }

    /**
     * Gets min_height
     *
     * @return float|null
     */
    public function getMinHeight()
    {
        return $this->container['min_height'];
    }

    /**
     * Sets min_height
     *
     * @param float|null $min_height The minimum height of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMinHeight($min_height)
    {
        if (is_null($min_height)) {
            throw new \InvalidArgumentException('non-nullable min_height cannot be null');
        }
        $this->container['min_height'] = $min_height;

        return $this;
    }

    /**
     * Gets max_height
     *
     * @return float|null
     */
    public function getMaxHeight()
    {
        return $this->container['max_height'];
    }

    /**
     * Sets max_height
     *
     * @param float|null $max_height The maximum height of the frame. This property is only applicable for auto-layout frames or direct children of auto-layout frames.
     *
     * @return self
     */
    public function setMaxHeight($max_height)
    {
        if (is_null($max_height)) {
            throw new \InvalidArgumentException('non-nullable max_height cannot be null');
        }
        $this->container['max_height'] = $max_height;

        return $this;
    }

    /**
     * Gets layout_sizing_horizontal
     *
     * @return string|null
     */
    public function getLayoutSizingHorizontal()
    {
        return $this->container['layout_sizing_horizontal'];
    }

    /**
     * Sets layout_sizing_horizontal
     *
     * @param string|null $layout_sizing_horizontal The horizontal sizing setting on this auto-layout frame or frame child. - `FIXED` - `HUG`: only valid on auto-layout frames and text nodes - `FILL`: only valid on auto-layout frame children
     *
     * @return self
     */
    public function setLayoutSizingHorizontal($layout_sizing_horizontal)
    {
        if (is_null($layout_sizing_horizontal)) {
            throw new \InvalidArgumentException('non-nullable layout_sizing_horizontal cannot be null');
        }
        $allowedValues = $this->getLayoutSizingHorizontalAllowableValues();
        if (!in_array($layout_sizing_horizontal, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_sizing_horizontal', must be one of '%s'",
                    $layout_sizing_horizontal,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_sizing_horizontal'] = $layout_sizing_horizontal;

        return $this;
    }

    /**
     * Gets layout_sizing_vertical
     *
     * @return string|null
     */
    public function getLayoutSizingVertical()
    {
        return $this->container['layout_sizing_vertical'];
    }

    /**
     * Sets layout_sizing_vertical
     *
     * @param string|null $layout_sizing_vertical The vertical sizing setting on this auto-layout frame or frame child. - `FIXED` - `HUG`: only valid on auto-layout frames and text nodes - `FILL`: only valid on auto-layout frame children
     *
     * @return self
     */
    public function setLayoutSizingVertical($layout_sizing_vertical)
    {
        if (is_null($layout_sizing_vertical)) {
            throw new \InvalidArgumentException('non-nullable layout_sizing_vertical cannot be null');
        }
        $allowedValues = $this->getLayoutSizingVerticalAllowableValues();
        if (!in_array($layout_sizing_vertical, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'layout_sizing_vertical', must be one of '%s'",
                    $layout_sizing_vertical,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['layout_sizing_vertical'] = $layout_sizing_vertical;

        return $this;
    }

    /**
     * Gets grid_row_count
     *
     * @return float|null
     */
    public function getGridRowCount()
    {
        return $this->container['grid_row_count'];
    }

    /**
     * Sets grid_row_count
     *
     * @param float|null $grid_row_count The number of rows in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowCount($grid_row_count)
    {
        if (is_null($grid_row_count)) {
            throw new \InvalidArgumentException('non-nullable grid_row_count cannot be null');
        }
        $this->container['grid_row_count'] = $grid_row_count;

        return $this;
    }

    /**
     * Gets grid_column_count
     *
     * @return float|null
     */
    public function getGridColumnCount()
    {
        return $this->container['grid_column_count'];
    }

    /**
     * Sets grid_column_count
     *
     * @param float|null $grid_column_count The number of columns in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnCount($grid_column_count)
    {
        if (is_null($grid_column_count)) {
            throw new \InvalidArgumentException('non-nullable grid_column_count cannot be null');
        }
        $this->container['grid_column_count'] = $grid_column_count;

        return $this;
    }

    /**
     * Gets grid_row_gap
     *
     * @return float|null
     */
    public function getGridRowGap()
    {
        return $this->container['grid_row_gap'];
    }

    /**
     * Sets grid_row_gap
     *
     * @param float|null $grid_row_gap The distance between rows in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowGap($grid_row_gap)
    {
        if (is_null($grid_row_gap)) {
            throw new \InvalidArgumentException('non-nullable grid_row_gap cannot be null');
        }
        $this->container['grid_row_gap'] = $grid_row_gap;

        return $this;
    }

    /**
     * Gets grid_column_gap
     *
     * @return float|null
     */
    public function getGridColumnGap()
    {
        return $this->container['grid_column_gap'];
    }

    /**
     * Sets grid_column_gap
     *
     * @param float|null $grid_column_gap The distance between columns in the grid layout. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnGap($grid_column_gap)
    {
        if (is_null($grid_column_gap)) {
            throw new \InvalidArgumentException('non-nullable grid_column_gap cannot be null');
        }
        $this->container['grid_column_gap'] = $grid_column_gap;

        return $this;
    }

    /**
     * Gets grid_columns_sizing
     *
     * @return string|null
     */
    public function getGridColumnsSizing()
    {
        return $this->container['grid_columns_sizing'];
    }

    /**
     * Sets grid_columns_sizing
     *
     * @param string|null $grid_columns_sizing The string for the CSS grid-template-columns property. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnsSizing($grid_columns_sizing)
    {
        if (is_null($grid_columns_sizing)) {
            throw new \InvalidArgumentException('non-nullable grid_columns_sizing cannot be null');
        }
        $this->container['grid_columns_sizing'] = $grid_columns_sizing;

        return $this;
    }

    /**
     * Gets grid_rows_sizing
     *
     * @return string|null
     */
    public function getGridRowsSizing()
    {
        return $this->container['grid_rows_sizing'];
    }

    /**
     * Sets grid_rows_sizing
     *
     * @param string|null $grid_rows_sizing The string for the CSS grid-template-rows property. This property is only applicable for auto-layout frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowsSizing($grid_rows_sizing)
    {
        if (is_null($grid_rows_sizing)) {
            throw new \InvalidArgumentException('non-nullable grid_rows_sizing cannot be null');
        }
        $this->container['grid_rows_sizing'] = $grid_rows_sizing;

        return $this;
    }

    /**
     * Gets grid_child_horizontal_align
     *
     * @return string|null
     */
    public function getGridChildHorizontalAlign()
    {
        return $this->container['grid_child_horizontal_align'];
    }

    /**
     * Sets grid_child_horizontal_align
     *
     * @param string|null $grid_child_horizontal_align Determines how a GRID frame's child should be aligned in the horizontal direction within its grid area. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridChildHorizontalAlign($grid_child_horizontal_align)
    {
        if (is_null($grid_child_horizontal_align)) {
            throw new \InvalidArgumentException('non-nullable grid_child_horizontal_align cannot be null');
        }
        $allowedValues = $this->getGridChildHorizontalAlignAllowableValues();
        if (!in_array($grid_child_horizontal_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'grid_child_horizontal_align', must be one of '%s'",
                    $grid_child_horizontal_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['grid_child_horizontal_align'] = $grid_child_horizontal_align;

        return $this;
    }

    /**
     * Gets grid_child_vertical_align
     *
     * @return string|null
     */
    public function getGridChildVerticalAlign()
    {
        return $this->container['grid_child_vertical_align'];
    }

    /**
     * Sets grid_child_vertical_align
     *
     * @param string|null $grid_child_vertical_align Determines how a GRID frame's child should be aligned in the vertical direction within its grid area. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridChildVerticalAlign($grid_child_vertical_align)
    {
        if (is_null($grid_child_vertical_align)) {
            throw new \InvalidArgumentException('non-nullable grid_child_vertical_align cannot be null');
        }
        $allowedValues = $this->getGridChildVerticalAlignAllowableValues();
        if (!in_array($grid_child_vertical_align, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'grid_child_vertical_align', must be one of '%s'",
                    $grid_child_vertical_align,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['grid_child_vertical_align'] = $grid_child_vertical_align;

        return $this;
    }

    /**
     * Gets grid_row_span
     *
     * @return float|null
     */
    public function getGridRowSpan()
    {
        return $this->container['grid_row_span'];
    }

    /**
     * Sets grid_row_span
     *
     * @param float|null $grid_row_span The number of rows that a GRID frame's child should span. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowSpan($grid_row_span)
    {
        if (is_null($grid_row_span)) {
            throw new \InvalidArgumentException('non-nullable grid_row_span cannot be null');
        }
        $this->container['grid_row_span'] = $grid_row_span;

        return $this;
    }

    /**
     * Gets grid_column_span
     *
     * @return float|null
     */
    public function getGridColumnSpan()
    {
        return $this->container['grid_column_span'];
    }

    /**
     * Sets grid_column_span
     *
     * @param float|null $grid_column_span The number of columns that a GRID frame's child should span. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnSpan($grid_column_span)
    {
        if (is_null($grid_column_span)) {
            throw new \InvalidArgumentException('non-nullable grid_column_span cannot be null');
        }
        $this->container['grid_column_span'] = $grid_column_span;

        return $this;
    }

    /**
     * Gets grid_row_anchor_index
     *
     * @return float|null
     */
    public function getGridRowAnchorIndex()
    {
        return $this->container['grid_row_anchor_index'];
    }

    /**
     * Sets grid_row_anchor_index
     *
     * @param float|null $grid_row_anchor_index The index of the row that a GRID frame's child should be anchored to. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridRowAnchorIndex($grid_row_anchor_index)
    {
        if (is_null($grid_row_anchor_index)) {
            throw new \InvalidArgumentException('non-nullable grid_row_anchor_index cannot be null');
        }
        $this->container['grid_row_anchor_index'] = $grid_row_anchor_index;

        return $this;
    }

    /**
     * Gets grid_column_anchor_index
     *
     * @return float|null
     */
    public function getGridColumnAnchorIndex()
    {
        return $this->container['grid_column_anchor_index'];
    }

    /**
     * Sets grid_column_anchor_index
     *
     * @param float|null $grid_column_anchor_index The index of the column that a GRID frame's child should be anchored to. This property is only applicable for direct children of frames with `layoutMode: \"GRID\"`.
     *
     * @return self
     */
    public function setGridColumnAnchorIndex($grid_column_anchor_index)
    {
        if (is_null($grid_column_anchor_index)) {
            throw new \InvalidArgumentException('non-nullable grid_column_anchor_index cannot be null');
        }
        $this->container['grid_column_anchor_index'] = $grid_column_anchor_index;

        return $this;
    }

    /**
     * Gets characters
     *
     * @return string
     */
    public function getCharacters()
    {
        return $this->container['characters'];
    }

    /**
     * Sets characters
     *
     * @param string $characters Text contained within a text box.
     *
     * @return self
     */
    public function setCharacters($characters)
    {
        if (is_null($characters)) {
            throw new \InvalidArgumentException('non-nullable characters cannot be null');
        }
        $this->container['characters'] = $characters;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


