<?php
/**
 * ImagePaint
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.33.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.15.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * ImagePaint Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class ImagePaint implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'ImagePaint';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'visible' => 'bool',
        'opacity' => 'float',
        'blend_mode' => '\OpenAPI\Client\Model\BlendMode',
        'type' => 'string',
        'scale_mode' => 'string',
        'image_ref' => 'string',
        'image_transform' => 'float[][]',
        'scaling_factor' => 'float',
        'filters' => '\OpenAPI\Client\Model\ImageFilters',
        'rotation' => 'float',
        'gif_ref' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'visible' => null,
        'opacity' => null,
        'blend_mode' => null,
        'type' => null,
        'scale_mode' => null,
        'image_ref' => null,
        'image_transform' => null,
        'scaling_factor' => null,
        'filters' => null,
        'rotation' => null,
        'gif_ref' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'visible' => false,
        'opacity' => false,
        'blend_mode' => false,
        'type' => false,
        'scale_mode' => false,
        'image_ref' => false,
        'image_transform' => false,
        'scaling_factor' => false,
        'filters' => false,
        'rotation' => false,
        'gif_ref' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'visible' => 'visible',
        'opacity' => 'opacity',
        'blend_mode' => 'blendMode',
        'type' => 'type',
        'scale_mode' => 'scaleMode',
        'image_ref' => 'imageRef',
        'image_transform' => 'imageTransform',
        'scaling_factor' => 'scalingFactor',
        'filters' => 'filters',
        'rotation' => 'rotation',
        'gif_ref' => 'gifRef'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'visible' => 'setVisible',
        'opacity' => 'setOpacity',
        'blend_mode' => 'setBlendMode',
        'type' => 'setType',
        'scale_mode' => 'setScaleMode',
        'image_ref' => 'setImageRef',
        'image_transform' => 'setImageTransform',
        'scaling_factor' => 'setScalingFactor',
        'filters' => 'setFilters',
        'rotation' => 'setRotation',
        'gif_ref' => 'setGifRef'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'visible' => 'getVisible',
        'opacity' => 'getOpacity',
        'blend_mode' => 'getBlendMode',
        'type' => 'getType',
        'scale_mode' => 'getScaleMode',
        'image_ref' => 'getImageRef',
        'image_transform' => 'getImageTransform',
        'scaling_factor' => 'getScalingFactor',
        'filters' => 'getFilters',
        'rotation' => 'getRotation',
        'gif_ref' => 'getGifRef'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_IMAGE = 'IMAGE';
    public const SCALE_MODE_FILL = 'FILL';
    public const SCALE_MODE_FIT = 'FIT';
    public const SCALE_MODE_TILE = 'TILE';
    public const SCALE_MODE_STRETCH = 'STRETCH';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_IMAGE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScaleModeAllowableValues()
    {
        return [
            self::SCALE_MODE_FILL,
            self::SCALE_MODE_FIT,
            self::SCALE_MODE_TILE,
            self::SCALE_MODE_STRETCH,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('visible', $data ?? [], true);
        $this->setIfExists('opacity', $data ?? [], 1);
        $this->setIfExists('blend_mode', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('scale_mode', $data ?? [], null);
        $this->setIfExists('image_ref', $data ?? [], null);
        $this->setIfExists('image_transform', $data ?? [], null);
        $this->setIfExists('scaling_factor', $data ?? [], null);
        $this->setIfExists('filters', $data ?? [], null);
        $this->setIfExists('rotation', $data ?? [], 0);
        $this->setIfExists('gif_ref', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if (!is_null($this->container['opacity']) && ($this->container['opacity'] > 1)) {
            $invalidProperties[] = "invalid value for 'opacity', must be smaller than or equal to 1.";
        }

        if (!is_null($this->container['opacity']) && ($this->container['opacity'] < 0)) {
            $invalidProperties[] = "invalid value for 'opacity', must be bigger than or equal to 0.";
        }

        if ($this->container['blend_mode'] === null) {
            $invalidProperties[] = "'blend_mode' can't be null";
        }
        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['scale_mode'] === null) {
            $invalidProperties[] = "'scale_mode' can't be null";
        }
        $allowedValues = $this->getScaleModeAllowableValues();
        if (!is_null($this->container['scale_mode']) && !in_array($this->container['scale_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scale_mode', must be one of '%s'",
                $this->container['scale_mode'],
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['image_ref'] === null) {
            $invalidProperties[] = "'image_ref' can't be null";
        }
        if (!is_null($this->container['image_transform']) && (count($this->container['image_transform']) > 2)) {
            $invalidProperties[] = "invalid value for 'image_transform', number of items must be less than or equal to 2.";
        }

        if (!is_null($this->container['image_transform']) && (count($this->container['image_transform']) < 2)) {
            $invalidProperties[] = "invalid value for 'image_transform', number of items must be greater than or equal to 2.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets visible
     *
     * @return bool|null
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool|null $visible Is the paint enabled?
     *
     * @return self
     */
    public function setVisible($visible)
    {
        if (is_null($visible)) {
            throw new \InvalidArgumentException('non-nullable visible cannot be null');
        }
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets opacity
     *
     * @return float|null
     */
    public function getOpacity()
    {
        return $this->container['opacity'];
    }

    /**
     * Sets opacity
     *
     * @param float|null $opacity Overall opacity of paint (colors within the paint can also have opacity values which would blend with this)
     *
     * @return self
     */
    public function setOpacity($opacity)
    {
        if (is_null($opacity)) {
            throw new \InvalidArgumentException('non-nullable opacity cannot be null');
        }

        if (($opacity > 1)) {
            throw new \InvalidArgumentException('invalid value for $opacity when calling ImagePaint., must be smaller than or equal to 1.');
        }
        if (($opacity < 0)) {
            throw new \InvalidArgumentException('invalid value for $opacity when calling ImagePaint., must be bigger than or equal to 0.');
        }

        $this->container['opacity'] = $opacity;

        return $this;
    }

    /**
     * Gets blend_mode
     *
     * @return \OpenAPI\Client\Model\BlendMode
     */
    public function getBlendMode()
    {
        return $this->container['blend_mode'];
    }

    /**
     * Sets blend_mode
     *
     * @param \OpenAPI\Client\Model\BlendMode $blend_mode How this node blends with nodes behind it in the scene
     *
     * @return self
     */
    public function setBlendMode($blend_mode)
    {
        if (is_null($blend_mode)) {
            throw new \InvalidArgumentException('non-nullable blend_mode cannot be null');
        }
        $this->container['blend_mode'] = $blend_mode;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type The string literal \"IMAGE\" representing the paint's type. Always check the `type` before reading other properties.
     *
     * @return self
     */
    public function setType($type)
    {
        if (is_null($type)) {
            throw new \InvalidArgumentException('non-nullable type cannot be null');
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets scale_mode
     *
     * @return string
     */
    public function getScaleMode()
    {
        return $this->container['scale_mode'];
    }

    /**
     * Sets scale_mode
     *
     * @param string $scale_mode Image scaling mode.
     *
     * @return self
     */
    public function setScaleMode($scale_mode)
    {
        if (is_null($scale_mode)) {
            throw new \InvalidArgumentException('non-nullable scale_mode cannot be null');
        }
        $allowedValues = $this->getScaleModeAllowableValues();
        if (!in_array($scale_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scale_mode', must be one of '%s'",
                    $scale_mode,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scale_mode'] = $scale_mode;

        return $this;
    }

    /**
     * Gets image_ref
     *
     * @return string
     */
    public function getImageRef()
    {
        return $this->container['image_ref'];
    }

    /**
     * Sets image_ref
     *
     * @param string $image_ref A reference to an image embedded in this node. To download the image using this reference, use the `GET file images` endpoint to retrieve the mapping from image references to image URLs.
     *
     * @return self
     */
    public function setImageRef($image_ref)
    {
        if (is_null($image_ref)) {
            throw new \InvalidArgumentException('non-nullable image_ref cannot be null');
        }
        $this->container['image_ref'] = $image_ref;

        return $this;
    }

    /**
     * Gets image_transform
     *
     * @return float[][]|null
     */
    public function getImageTransform()
    {
        return $this->container['image_transform'];
    }

    /**
     * Sets image_transform
     *
     * @param float[][]|null $image_transform A transformation matrix is standard way in computer graphics to represent translation and rotation. These are the top two rows of a 3x3 matrix. The bottom row of the matrix is assumed to be [0, 0, 1]. This is known as an affine transform and is enough to represent translation, rotation, and skew.  The identity transform is [[1, 0, 0], [0, 1, 0]].  A translation matrix will typically look like:  ``` [[1, 0, tx],   [0, 1, ty]] ```  and a rotation matrix will typically look like:  ``` [[cos(angle), sin(angle), 0],   [-sin(angle), cos(angle), 0]] ```  Another way to think about this transform is as three vectors:  - The x axis (t[0][0], t[1][0]) - The y axis (t[0][1], t[1][1]) - The translation offset (t[0][2], t[1][2])  The most common usage of the Transform matrix is the `relativeTransform property`. This particular usage of the matrix has a few additional restrictions. The translation offset can take on any value but we do enforce that the axis vectors are unit vectors (i.e. have length 1). The axes are not required to be at 90° angles to each other.
     *
     * @return self
     */
    public function setImageTransform($image_transform)
    {
        if (is_null($image_transform)) {
            throw new \InvalidArgumentException('non-nullable image_transform cannot be null');
        }

        if ((count($image_transform) > 2)) {
            throw new \InvalidArgumentException('invalid value for $image_transform when calling ImagePaint., number of items must be less than or equal to 2.');
        }
        if ((count($image_transform) < 2)) {
            throw new \InvalidArgumentException('invalid length for $image_transform when calling ImagePaint., number of items must be greater than or equal to 2.');
        }
        $this->container['image_transform'] = $image_transform;

        return $this;
    }

    /**
     * Gets scaling_factor
     *
     * @return float|null
     */
    public function getScalingFactor()
    {
        return $this->container['scaling_factor'];
    }

    /**
     * Sets scaling_factor
     *
     * @param float|null $scaling_factor Amount image is scaled by in tiling, only present if scaleMode is `TILE`.
     *
     * @return self
     */
    public function setScalingFactor($scaling_factor)
    {
        if (is_null($scaling_factor)) {
            throw new \InvalidArgumentException('non-nullable scaling_factor cannot be null');
        }
        $this->container['scaling_factor'] = $scaling_factor;

        return $this;
    }

    /**
     * Gets filters
     *
     * @return \OpenAPI\Client\Model\ImageFilters|null
     */
    public function getFilters()
    {
        return $this->container['filters'];
    }

    /**
     * Sets filters
     *
     * @param \OpenAPI\Client\Model\ImageFilters|null $filters Defines what image filters have been applied to this paint, if any. If this property is not defined, no filters have been applied.
     *
     * @return self
     */
    public function setFilters($filters)
    {
        if (is_null($filters)) {
            throw new \InvalidArgumentException('non-nullable filters cannot be null');
        }
        $this->container['filters'] = $filters;

        return $this;
    }

    /**
     * Gets rotation
     *
     * @return float|null
     */
    public function getRotation()
    {
        return $this->container['rotation'];
    }

    /**
     * Sets rotation
     *
     * @param float|null $rotation Image rotation, in degrees.
     *
     * @return self
     */
    public function setRotation($rotation)
    {
        if (is_null($rotation)) {
            throw new \InvalidArgumentException('non-nullable rotation cannot be null');
        }
        $this->container['rotation'] = $rotation;

        return $this;
    }

    /**
     * Gets gif_ref
     *
     * @return string|null
     */
    public function getGifRef()
    {
        return $this->container['gif_ref'];
    }

    /**
     * Sets gif_ref
     *
     * @param string|null $gif_ref A reference to an animated GIF embedded in this node. To download the image using this reference, use the `GET file images` endpoint to retrieve the mapping from image references to image URLs.
     *
     * @return self
     */
    public function setGifRef($gif_ref)
    {
        if (is_null($gif_ref)) {
            throw new \InvalidArgumentException('non-nullable gif_ref cannot be null');
        }
        $this->container['gif_ref'] = $gif_ref;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


